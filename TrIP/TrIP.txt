//############################ TRYPANOSOME IMAGE PIPELINE (TrIP) ANALYSIS ############################ 
//
//====================================================================================================
//                        Developed by Dr Christopher Kay & Rachel Hutchinson
//                                     Bristol Trypanosome Group
//                                      University of Bristol
//====================================================================================================
//
//  IMPORTANT: 
//    1.  This version is optimised for T. suis.
//    2.  This macro includes sections of code written in preparation of additional functionality, which is redundant in this 
//        version, but has been included in this script to indicate the potential for development.
//    3.  Microscopes must be individually calibrated. See section
//    4.  a number of image sets (up to 2/3 the total number of files in the folder) may be excluded before it starts causing problems, as the macro may fail to process all the sets in the file if numbering is random.  		
//
Current_version = "TRIP v1.1"
//
// ### PREPARATION OF IMAGE INPUT ###
// Images must be labelled as consecutive sets (starting at 1), with a suffix designator of image type (see below), followed by .tif: 
//		Image types:
//			bf	brightfield
//			d	DAPI stain
//			h	hoechst 33342 stain
//			g	green fluorescence
//			r	red fluorescence
//			y	yellow fluorescence
//
//		Sample dataset: 	1bf.tif 		1g.tif 			1h.tif
//					2bf.tif			2g.tif			2h.tif
//					3bf.tif			3g.tif			3h.tif
//
//
//
//
//################# 1. SETTING UP #################
// 	* FIGURING OUT WHAT TO DO
//	* DEFINE VARIABLES
//	* DEFINE FUNCTIONS
//	* GET WORKING DIRECTORY
//	* RECURSE IN DIRECTORY
//
//################# 1.1 EXTRACTING CELLS FROM MICROSCOPY IMAGES #################
//
//	DETERMINE OUTLINE AND SKELETON
//  	* OPEN FILE, SPLIT CHANNELS, DETERMINE BEST CHANNEL FOR OUTLINES 
//	* DETERMINE BEST SUBTRACT BACKGROUND RADIUS
//	* DETERMINE BEST NUMBER OF SMOOTHING ITERATIONS
//	* MAKING THE OUTLINE IMAGE
//	* MAKING THE SKELETON IMAGE
//
//	DETERMINING NUCLEAR STRUCTURES
// 	* OPEN FILE, SPLIT CHANNELS, DETERMINE BEST CHANNEL
//	* DETERMINE BEST SUBTRACT BACKGROUND RADIUS
//	* MAKE NUCLEAR STRUCTURE IMAGES (Multicolour composites)
//	* PREPARE CELL STACKS
//	* MANUAL CURATION OF OUTLINES
//	* MANUAL CURATION OF NUCLEI
//	* MANUAL CURATION OF KINETOPLASTS
//	* (IF MANUAL CURATION SELECTED, WILL REGENERATE MULTICOLOUR COMPOSITES AND PREPARE CELL STACKS FROM CURATED IMAGES)
//
//	EXTRACT CELLS FROM STACK
//	* USE OUTLINES TO GET CELLS
//	* MAKE STACK
//	* EXTRACT CELLS
//	* SAVE CELLS
//
// 	ANALYSE EXTRACTED CELLS
//  	* CHECK CELL SHAPE
//	* CHECK FOR NUCLEUS
//	* CKECK FOR KINETOPLASTS
//	* ASSESS SKELETON DERIVED FROM OUTLINE
//	* RIDGE DETECTION FOR LENGTH AND WIDTH
//	* SKELETON TRAVERSAL
//	* CELL ASSIGNMENT
//
// 	SORTING ANNOTATED CELLS 
//	* PREPARING CHANNELS
//
//###### POPULATION ANALYSIS #########################
//######################################################
	
Clear_log();
Processed_directory = 0;

//#################  1.1 USER SETTINGS ################# 
	
	Dialog.create("Trypanosome analysis suite");
		
	Dialog.addMessage(
		"TRYPANOSOME ANALYSIS SUITE \n"+
		" A crude tool for analysing microscopy image data \n\n:");
	Dialog.addChoice("Microscope:   " newArray("Leica epifluorescent", "Langford epiflourescent", "GX Cam"));
	Dialog.addChoice("Objective Magnification:" newArray("100x","63x","40x"), "40x");
	Dialog.addMessage("Eyepiece = x10");
	Dialog.addChoice("Cell type:    " newArray("All"));   //Included as array to allow settings to vary between morphological types/samples if required later
	Dialog.addChoice("Species:    " newArray("T. suis")); //Included as array to allow settings to vary for multiple species if required later
	Dialog.addCheckbox("Process outlines? ", true);
	//Dialog.addMessage(
	//	"Enabling this option performs processing on brightfield or 	\n"+
	//	"DIC images to extract cell outlines which are essential for	\n"+
	//	"certain downstream processes, the output of this process	\n"+
	//	"yields the files n-outline, n-skeleton and n-brightfield, 		\n"+
	//	"in addition to diagnostic pipeline images of each set.		\n\n");
	Dialog.addMessage("\nOutline settings:");
	Dialog.addChoice("Force colour channel:" newArray("Auto" ,"Red","Green","Blue"));
	Dialog.addChoice("Force radius:" newArray("Auto" ,"4","8","12","16","20","24"));
	Dialog.addChoice("Force contrast gain:" newArray("Auto" ,"1","3","5","7","9"));
	Dialog.addChoice("Tip Reinforcement:" newArray("On" ,"Off"));
	Dialog.addChoice("Run Unsharp mask:" newArray("On" ,"Off"));
	Dialog.addCheckbox("Skip to manual curation? [uses existing image_run_settings] ", false);
	Dialog.addChoice("Pause to draw troublesome flagella:" newArray("Off" ,"On"));
	
	Dialog.addCheckbox("\nProcess nuclear structures? ", true);
	//Dialog.addMessage(
	//	"Choose this option where the image set includes Hoechst or 	\n"+
	//	"DAPI staining, and information on the nuclear structures is 	\n"+
	//	"desired. This process is essential for identifying valid cells	\n"+
	//	"in downstream analyses. Products of this analysis are n-nuclei,\n"+
	//	"and n-kinetoplasts, as well as diagnostic intermediates.		\n\n");
	Dialog.addChoice("Force colour channel:" newArray("Auto" ,"Red","Green","Blue"));
	Dialog.addChoice("Force contrast gain:" newArray("Auto" ,"1","3","5","7","9"));
	Dialog.addChoice("Nuclei min area:" newArray("70" ,"100","50","25"));
	
	Dialog.addCheckbox("Generate multicolour composite? ", true);
	//Dialog.addMessage(
	//	"This option simply gives the opportunity to generate a useful	\n"+
	//	"composite image showing outline, and colour coded nuclei and 	\n"+
	//	"kinetoplasts. Useful for determining if the pipeline is ok.	\n\n");
	
	Dialog.addCheckbox("Prepare cell stacks?", true);
	Dialog.addCheckbox("Manually curate outlines? ", true);
	Dialog.addCheckbox("Manually curate nuclear structures? ", true);
	// Dialog.addMessage(
	//	"If manual curation selected, currently there is no option to ONLY curate nuclear structures");
	Dialog.addCheckbox("Start after manual?", false);
	Dialog.addCheckbox("Extract cell stacks? ", true);
	
	//Dialog.addMessage(
	//	"This combines the above analyses and results in stacks for		\n"+
	//	"each identified cell cropped out of the original images. In 	\n"+
	//	"the format (n)Cell(n)-stack, the first number indicating which \n"+
	//	"set of pictures the cell was extracted from, and the second the\n"+
	//	"unique number for each cell found in that image				\n\n");
		
	Dialog.addCheckbox("Analyse extracted cells? ", true);
	//Dialog.addMessage(
	//	"Enabling this performs a second round of analysis on the		\n"+
	//	"extracted cell stacks, at this point cells are assessed for  	\n"+
	//	"validity based on nuclei and outlines where data is available. \n"+
	//	"note that this option deletes invalid cells, also that at this \n"+
	//	"stage (n)Cell(n)-montage and (n)Cell(n)-text  is produced.		\n\n");
	Dialog.addCheckbox("Get non-dividing singlets? ", true);
	//Dialog.addMessage(
	//	"This option extracts all single, non-dividing valid cells to 	\n"+
	//	"a folder called 'clean singlets' and performs some population 	\n"+
	//	"analysis.	\n\n");
	Dialog.addCheckbox("Get putative dividers? ", true);
	Dialog.show();
	
//################# 1.1.1 GET VARIABLES FROM DIALOG ################# 
	
	print("wwwww RUN SETTINGS wwwww");
	print(""+Current_version+"");
		
	Microscope_choice = Dialog.getChoice();				print("Microscope choice: "+Microscope_choice);
	Magnification_choice = Dialog.getChoice();				print("Magnification choice: "+Magnification_choice);
	Cell_type_choice = Dialog.getChoice();					print("Cell_type_choice: "+Cell_type_choice);	//SS+ added cell type option in case need to change parameters for different cell types/populations
	Species_choice = Dialog.getChoice();					print("Species choice: "+Species_choice);
	
	Process_outlines = Dialog.getCheckbox();				print("Process outlines: "+Process_outlines);
	Outline_channel_choice = Dialog.getChoice();			
	Outline_subtract_radius = Dialog.getChoice();			
	Outline_anti_alias_gain = Dialog.getChoice();			
	Tip_reinforcement = Dialog.getChoice();				print("Reinforce tips: "+Tip_reinforcement);
	Run_unsharp_enable = Dialog.getChoice();				print("Run Unsharp: "+Run_unsharp_enable);
	Use_existing_run_settings = Dialog.getCheckbox();		print("Skip to manual curation? [uses existing image_run_settings] "+Use_existing_run_settings);
	if (0==Use_existing_run_settings)						// won't print these selections if using existing run settings
		{
		print("Channel choice: "+Outline_channel_choice);
		print("Subtract background radius choice: "+Outline_subtract_radius);
		print("Outline gain choice: "+Outline_anti_alias_gain);
		}
	Pause_for_tip_drawing = Dialog.getChoice();			print("Pause for tip drawing: "+Pause_for_tip_drawing);
	
	Process_nuclear_structures = Dialog.getCheckbox();		print("Process nuclear structures: "+Process_nuclear_structures);
	Nuclear_channel_choice = Dialog.getChoice();			print("Nuclear Channel choice: "+Nuclear_channel_choice);
	Nuclear_stain_gain = Dialog.getChoice();				print("Outline gain choice: "+Nuclear_stain_gain);
	Nuclear_min_area = Dialog.getChoice();				print("Outline gain choice: "+Nuclear_min_area);
	
	Generate_multicolour_composite = Dialog.getCheckbox();	print("Generate multicolour composite: "+Generate_multicolour_composite);	
	Prepare_cell_stacks = Dialog.getCheckbox();			print("Prepare cell stacks: "+Prepare_cell_stacks);  
	Manually_curate_ROI = Dialog.getCheckbox();			print("Manually curate: "+Manually_curate_ROI);
	Manually_curate_nuclearROI = Dialog.getCheckbox();		print("Manually curate nuclear structures: "+Manually_curate_nuclearROI);
	Start_post_manual = Dialog.getCheckbox();				print("Starting from after manual corrections step: "+Start_post_manual);
	Extract_cell_stacks = Dialog.getCheckbox();				print("Extract cell stacks: "+Extract_cell_stacks);
	Analyse_extracted_cells = Dialog.getCheckbox();			print("Analyse extracted cells: "+Analyse_extracted_cells);
	Get_non_dividing_singlets = Dialog.getCheckbox();		print("Get non-dividing singlets: "+Get_non_dividing_singlets);
	Get_putative_dividers = Dialog.getCheckbox();			print("Get putative dividers: "+Get_putative_dividers);
	
//################# 1.1.2 ADDITIONAL SETTINGS ######################

	Dialog.create("Additional Input");
	Dialog.addMessage(
		"Additional settings for Trypanosome Analysis Suite\n"+
		"For default settings, select OK \n");
	Dialog.addNumber("Start at image:", 1);
	Dialog.addNumber("Max number of cells per image:", 100);
	Dialog.show();

	print("wwwww ADDITIONAL SETTINGS wwwww");

	Starting_image = Dialog.getNumber();		print("Starting at image: "+Starting_image+".tif"); 									//SS+ Allows for fact that might not always start at 1
	Max_cells_per_image = Dialog.getNumber(); 	print("Max number of cells per image: "+Max_cells_per_image+""); 					//SS+ Used for determining enrichment upper limits (3 times this value)	
	

//###### HANDLE USER CHOICES #####################
//##################################################
	
	setOption("ExpandableArrays", true);										// Set so we can have string arrays

	// Global conversion from dialogue choices

//Setting Microscope_resolution
	if (Microscope_choice=="Leica epifluorescent")
		{
		if (Magnification_choice=="40x")
			{Scale_calibration = 6.3567;}  // 6.3567 pixels/um for image 1824x1368
		if (Magnification_choice=="63x")
			{Scale_calibration = 10.3993;} //10.3993 pixels/um for image 1824x1368
		if (Magnification_choice=="100x")
			{Scale_calibration = 16.6431;} //16.6431 pixels/um for image 1824x1368
		else	{print("Magnification choice not calibrated for this microscope. Please select another option."); break;}
		}							//
	else if (Microscope_choice=="Langford epiflourescent")
		{
		if (Magnification_choice=="40x")
			{Scale_calibration = 6.1594;}  // 6.159 pixels/um for image 
		if (Magnification_choice=="20x")
			{Scale_calibration = 3.1079;} // 3107.88 pixels/um
		else	{print("Magnification choice not calibrated for this microscope. Please select another option."); break;}
		}
	else if (Microscope_choice=="GX Cam")
		{
		if (Magnification_choice=="40x")
			{Scale_calibration = 5.3229;} // 5.3229 pixels/um for image 2560x1922
		else	{print("Magnification choice not calibrated for this microscope. Please select another option."); break;}
		}
	else {print("Something went wrong with the dialogue choice"); break;}
	
// Setting Cell Type 
//SS+ Included to allow variation between cell/sample types later
	if(Cell_type_choice=="All")
		{Cell_type = 0;}
	else {print("Something went wrong with the dialogue choice"); break;}
//Setting Species_selection
	if(Species_choice=="T. suis")
		{Species_value = 0;}
	//else if(Species_choice=="other trypanosome species")		//Included to allow the pipeline to be adapted for different populations/cells
	//	{Species_value = 1;}
	else {print("Something went wrong with the dialogue choice"); break;}

// combine above into function for correcting for optical system
function Imaging_variables(x) 
	{
	return (x * Scale_calibration); // in order to obtain pixel values for our measurements, we have to multiply out set meaurements (um) by the scale_calibration
	}

function Convert_to_microns(x)
	{
	return (x / Scale_calibration);
	}


//################# DEFINE VARIABLES ##########################################
// * data schema and variables
// * variables for outline processing
// * variables for nuclear stain processing
// * variables for cell anaylsis
//#############################################################################
		
//###### DATA SCHEMA #############################

	// Expected input files
	
	Image_types = newArray; 									// Create an array to hold the file suffixes we expect
	Image_types[0] = "bf"; 										// Brightfield
	Image_types[1] = "h"; 										// Hoechst
	Image_types[2] = "d";										// DAPI
	Image_types[3] = "g";										// GFP
	Image_types[4] = "r";										// RFP
	Image_types[5] = "y";										// YFP
	Image_types[6] = "m";										// 'multi' ie Lori's BFD 
	
	Image_types_brightfield = newArray;						// bunch the above into the category they should be processed as
	Image_types_brightfield[0] = Image_types[0];				// assign (X)bf.tifs as brightfield
	
	Image_types_nuclear = newArray;						// Types of nuclear stain
	Image_types_nuclear[0] = Image_types[1];					// Hoechst is considered here as a nuclear stain
	Image_types_nuclear[1] = Image_types[2];					// DAPI is considered here as a nuclear stain
	
	Image_types_fluorescence = newArray;					// Types of fluorescence
	Image_types_fluorescence[0] = Image_types[3];				// GFP considered as a fluorescence channel
	Image_types_fluorescence[0] = Image_types[4];				// YFP considered as a fluorescence channel
	Image_types_fluorescence[0] = Image_types[5];				// RFP considered as a fluorescence channel
	
	// Expected outputs of cell extraction
	
	// Diagnostic images are labelled pipe(n) according to the order in which they are taken
	// cropped images of original channels
	
	// enhanced brightfield outline; n-brightfield.tif
	// n-outline.tif, this will always be present in the resulting stacks
	// n-skeleton.tif
	// n-nuclei.tif
	// n-kinetoplasts.tif


//###### VARIABLES ###############################
//################################################

//###### SETTING ARRAYS BASED ON SPECIES AND CELL TYPE ############################### 
// SS+ Added this section to allow variables to be set per species and per cell type (if required)

// This layout allows variables to be tweaked for each species
// These settings are in microns squared
// Defaults min:500 max:4000 knrelative:10 n_multi:4 k_multi:4

// Minimum/Maximum --> setup array for species specific minima and maxima		
// Kin/Nuc relative scale --> Difference in area between minimum acceptable nuclei and kinetoplasts
// Nuc_multi --> How much more area than minimum a nucleus is allowed to be 
// Kin_multi --> How much more area than minimum a kinetoplast is allowed to be
// Min_skel_div --> Increasing allows smaller skeletons, ie fat but short cells
// Max_skel_multi --> Increasing allows for larger skeletons
// Circularity --> Used in determining what is too round to be a tryp, for rounder tryps, increase maximum
// Circularity Upper cell limit --> any value greater than this is deleted
// Solidity lower limit --> any value lower than this is deleted

// Declare arrays as global variables, then edit them based on species selection
// Arrays used to allow variation of settings for different cell types if need to add later.
	
	Minimum_tryp_area_array=0;
	Maximum_tryp_area_array=0;
	Kinetoplast_nucleus_minimum_relative_scale_array=0;
	Nucleus_multiplier_of_minimum_array=0;
	Kinetoplast_multiplier_of_minimum_array=0;
	Minimum_skeleton_area_divisor_array=0;
	Maximum_skeleton_area_multiplier_array=0;
	Circularity_range_array=0;
	Circularity_upper_cell_limit = 0;
	Solidity_lower_cell_limit = 0;
	
	if (Species_value==0)									// T. suis
		{
		Minimum_tryp_area_array = newArray(350,350);   
		Maximum_tryp_area_array = newArray(4000,4000);
		Kinetoplast_nucleus_minimum_relative_scale_array = newArray(15,15);
		Nucleus_multiplier_of_minimum_array = newArray(7,7);	     
		Kinetoplast_multiplier_of_minimum_array = newArray(10,10); 
		Minimum_skeleton_area_divisor_array = newArray(20,20);		// SS+ increased from 10 to 20 (allow smaller skeletons, ie fat but short cells)
		Maximum_skeleton_area_multiplier_array = newArray(1,1); 
		Circularity_range_array = newArray("0.05-0.80", "0.05-0.08"); // these settings are pretty generous, might find we can take these down later
		Circularity_upper_cell_limit = 0.8;
		Solidity_lower_cell_limit = 0.4;
		}
		//else if (Species_value == 1)									//SS+ other trypanosome sp
		//{
		//Minimum_tryp_area_array = newArray(500,500,300,500,500);
		//Maximum_tryp_area_array = newArray(4000,4000,3500,4000,4000);
		//Kinetoplast_nucleus_minimum_relative_scale_array = newArray(10,10,10,10,10);
		//Nucleus_multiplier_of_minimum_array = newArray(4,4,4,4,4);
		//Kinetoplast_multiplier_of_minimum_array = newArray(4,4,4,4,4);
		//Minimum_skeleton_area_divisor_array = newArray(10,10,10,10,10);
		//Maximum_skeleton_area_multiplier_array = newArray(0.75,0.75,0.75,0.75,0.75); 
		//Circularity_range_array = newArray("0.10-0.50", "0.10-0.50", "0.10-0.50", "0.10-0.50", "0.10-0.50");
		//Circularity_upper_cell_limit = 0.4;
		//Solidity_lower_cell_limit = 0.6;
		//};
	
//###### OUTLINE DETERMINATION ####################

	Min_tryp_area = Minimum_tryp_area_array[Cell_type];				// select species choice from array
	Min_tryp_area = Imaging_variables(Min_tryp_area);				// correct for optical setup
	print("Minimum trypanosome area: "+Min_tryp_area);				

	Max_tryp_area = Maximum_tryp_area_array[Cell_type];			// select species choice from array
	Max_tryp_area = Imaging_variables(Max_tryp_area);				// correct for optical setup
	print("Maximum trypanosome area: "+Max_tryp_area);				//
	
	Minimum_skeleton_area = floor(Min_tryp_area/Minimum_skeleton_area_divisor_array[Cell_type]);							
	print("Minimum skeleton area :"+Minimum_skeleton_area);
	
	Maximum_skeleton_area = floor(Min_tryp_area*Maximum_skeleton_area_multiplier_array[Cell_type]);			// SS+ increased from *0.75 to *1
	print("Maximum skeleton area: "+Maximum_skeleton_area);
	
	Prune_skeleton_threshold = floor(Minimum_skeleton_area/4);
	print("Prune skeleton threshold: "+Prune_skeleton_threshold);
	
	Circularity_range = Circularity_range_array[Cell_type]; 		//SS+ used later in working out outlines

	Channels = newArray; 											// Create an array to hold the names of our channels
	Channels[0] = "red";											// Enter our Channel names
	Channels[1] = "green"; 										//
	Channels[2] = "blue";											//

	// Channel performance
	Channels_performance = newArray; 								// Create an array to hold performance data for each channel
	Best_colour_channel = 0;										// Default the best channel to zero for brightfield analysis
	Channel_maximum = 0;

	// Subtract background determination
	Radius_trypanosomes = newArray; 								// Create an array to hold performance data for each channel
	Radius_fragments = newArray; 									// Create an array to hold performance data for each channel
	Radius_calculated_array = newArray;							
	Best_subtract_background_radius = 0;								// Default the best rolling ball radius for subtract background

	// Anti-alias gain determination

//######NUCLEAR STRUCTURES #####################

	Kinetoplast_nucleus_minimum_relative_scale = Kinetoplast_nucleus_minimum_relative_scale_array[Cell_type];
	print("Relative scale of nuclei to kineotoplasts: "+Kinetoplast_nucleus_minimum_relative_scale);
	
	Nucleus_multiplier_of_minimum = Nucleus_multiplier_of_minimum_array[Cell_type];				
	print("Multiple of minimum area for nuclei permitted: "+Nucleus_multiplier_of_minimum);
	
	Kinetoplast_multiplier_of_minimum = Kinetoplast_multiplier_of_minimum_array[Cell_type];			
	print("Multiple of minimum area for kinetoplasts permitted: "+Kinetoplast_multiplier_of_minimum);

	Nucleus_area_minimum = floor(Imaging_variables(parseInt(Nuclear_min_area)));						// Minimum size permitted for nuclei
	print("Minimum nucleus area: "+Nucleus_area_minimum);
	
	// also: Kinetoplast_nucleus_minimum_relative_scale !< Kinetoplast_multiplier_of_minimum
	// also: all structures fall within the range of Kinetoplast_area_minimum <=> Nucleus_area_maximum
	
	// These are calculated from above
	Nucleus_area_maximum = floor(Nucleus_area_minimum * Nucleus_multiplier_of_minimum);
	print("Maximum nucleus area: "+Nucleus_area_maximum);
		
	Kinetoplast_area_minimum = floor(Nucleus_area_minimum / Kinetoplast_nucleus_minimum_relative_scale);	//SS+ Changed to 1 (ignore scale)
	print("Minimum kinetoplast area: "+Kinetoplast_area_minimum);
		
	Kinetoplast_area_maximum = floor(Kinetoplast_area_minimum * Kinetoplast_multiplier_of_minimum);		//SS+ Changed to max 40 (ignore scaling)
	print("Maximum kinetoplast area: "+Kinetoplast_area_maximum);

	// variable re-used to determine structure yield
	Nuclear_structure_population = newArray;					//
	Noise_of_nuclear_structure_population = newArray;			//
	Oversize_of_nuclear_structure_population = newArray;		//
	Nuclear_structure_enrichment = newArray;					//
	Nuclear_structures_to_noise = 0;							//
	Best_colour_channel_for_nuclear_structures = 0;				
	
	// Best channel specific variables
	
	// Best Hoechst noise reduction variables

//######POST EXTRACTION PROCESSING ##############

	//Cell Data
	
	// Outline
	Circularity = 0;											// measure of circularity of outline - used to distinguish dead cells
	Solidity = 0;												// measure of tortuosity of outline perimeter - used to distinguish dead cells
	
	// Nuclear structures
	Number_of_nuclei = 0;										// records the number of nuclei detected in the cell
	Number_of_kinetoplasts = 0;								// records the number of kinetoplasts detected in the cell	
	Kinetoplast_centroids_X = newArray;							// centre point of kinetoplasts, X coordinates
	Kinetoplast_centroids_X[0] = 0;
	Nuclei_centroids_X = newArray;								// centre point of nuclei, X coordinates
	Nuclei_centroids_X[0] = 0;
	Kinetoplast_centroids_Y = newArray;							// centre point of kinetoplasts, Y coordinates
	Kinetoplast_centroids_Y[0] = 0;
	Nuclei_centroids_Y = newArray;								// centre point of nuclei, Y coordinates
	Nuclei_centroids_Y[0] = 0;
	Kinetoplast_areas = newArray;								// areas of kinetoplasts,
	Nuclei_areas = newArray;									// areas of nuclei,
	
	Nuclei_minimum_distance = 0;
	Nuclei_minimum = 0;
	Kinetoplast_minimum_distance = 0;
	Kinetoplast_minimum = 0;
	Kinetoplast_nuclei_distance = 0;
	
	//Skeleton
	Number_of_skeletons = 0;									// number of skeletons, if not 1, very worrying
	//Skeleton_length = 0;										// length of skeleton produced by skeletonising outline
	Number_of_triple_points = 0;								// number of triple points in the skeletonised outline- like junctions, none probably best
	Skeleton_branchedness = 0;								// measure of branchedness, each triple point ++
	Number_of_end_points = 0;									// should be 2, as in on a line
	Skeleton_quality = 0;										// 0 - do not use, 2 - cautiously use, 3 - ok for use
	
	Skeleton_length = 0;										// Length of skeleton measured as the sum of distances between pixel centerpoints
	Skeleton_area = 0;										// Number of pixels in skeleton NB not the same as length, non pythagorean
	Start_x = 0; Start_y = 0;									// Start coordinates for skeleton traversal - equal chance of being anterior or posterior

	//Ridge
	Cell_width = 0;											// average cell width from ridge detection
	Number_of_junctions = 0;									// number of junctions in centerline ridge in ridge detection - unjunctioned probably best
	ridge_branchedness = 0;									// measure of branchedness segment in summary ++
	Cumulative_ridge_length = 0;								// 
			


//################# FUNCTIONS ################################################
// Window handling
// Image conversion
// Contrast enhancement functions
// Analyse particle functions
//############################################################################

//###### WINDOW HANDLING / CLEANUP #####################

// Close specific image by title
function Close_image_by_title(title) 
	{
	selectWindow(title);
	close();
	}

// Close all open images 			
function Close_open_images()					// NOTE: This doesn't close image stacks.
	{
		while (nImages>0) 
		{ 
		selectImage(nImages); 
		close(); 	
		}
	}

// Clear log
function Clear_log()
	{print("\\Clear");}
	
// Clear ROI / Results
function Clear_ROI()
	{
	if(isOpen("ROI Manager"))
		{selectWindow("ROI Manager"); run("Close");}
	if(isOpen("Results"))		
		{selectWindow("Results"); run("Close");}
	}

// Clear ROI / Results
function Clear_non_image_windows()
	{
	if(isOpen("ROI Manager"))			{selectWindow("ROI Manager");			run("Close");}
	if(isOpen("Results"))				{selectWindow("Results"); 				run("Close");}
	if(isOpen("Summary"))				{selectWindow("Summary"); 			run("Close");}
	if(isOpen("Branch information"))		{selectWindow("Branch information"); 	run("Close");}
	if(isOpen("Junctions"))				{selectWindow("Junctions"); 			run("Close");}
	}
	
// Basic binary processing
function Basic_binary_processing(background)							// light or dark
	{
	setAutoThreshold("Default "+background+"");							// settings for threshold
	run("Convert to Mask");												// mask														
	run("Make Binary");												// make binary	
	run("Fill Holes");													// fill light voids in trypanosomes
	}

// Retrieve colour channel from image
function Retrieve_colour_channel_from_RGB_image(directory, title, channel)
	{
	Colour_channels = newArray; 										// Create an array to hold the names of our channels
	Colour_channels[0] = "red";											// Enter our Channel names
	Colour_channels[1] = "green"; 										//
	Colour_channels[2] = "blue";										//

	open(directory+title);												// Open file
	//run("RGB Color");
	run("Split Channels");												// Split channels
	for (c=0; c<Colour_channels.length; c++)								// For each channel
		{
		if (c!=channel)												// if channel is not selected channel
			{
			selectWindow(title+" ("+Colour_channels[c]+")");					// close channel
			close();
			}
		}
	}

// Take diagnostic image
function Take_diagnostic_image(Processed_directory, n, pipe)
	{
	run("Duplicate...", "title=["+n+"-pipe"+pipe+".tif]");					// duplicate the green channel to hoechst image			
	saveAs("Tiff", Processed_directory+n+"-pipe"+pipe+".tif"); 			//	
	print("Saved as "+n+"-pipe"+pipe+".tif");							// write to log
	Close_image_by_title(""+n+"-pipe"+pipe+".tif");						// clean up
	}

// Dilate and erode - joining isthmus in fragmented tryps
function Dilate_and_erode()
	{
	run("Dilate");
	run("Dilate");
	run("Fill Holes");
	run("Erode");
	run("Erode");
	}

//###### CONTRAST ENHANCEMENT FUNCTIONS ##############
	
// Antialias - remove edge fuzz in outline processing
function Antialias(gain)												// sort of a custom enhance contrast
	{
	run("8-bit");
	getRawStatistics( N, mn);
	run("Add...", "value=["+255-(mn)-(gain*2)+"]");
	run("Invert");													// invert
	run("Smooth");
	run("Despeckle");
	run("Multiply...", "value="+gain+"");								// make everything formerly not white darker
	run("Invert");
	run("Smooth");
	run("Despeckle");												// restore original
	}
	
// Reduce Hoechst stain noise
function Reduce_Hoechst_stain_noise(gain)
	{
	run("8-bit");
	getRawStatistics( N, mn);
	run("Despeckle");
	run("Subtract...", "value=["+(mn*gain/1.8)+"]");						// SS+ change from gain to gain/2
	run("Multiply...", "value="+(gain*1)+"");							// SS+ change from 1.5 to 1
	run("Auto Local Threshold", "method=Bernsen radius=60 parameter_1=0 parameter_2=0 white");			// radius here could probably benefit from being an expression of cell length	// SS+ changed Bernsen from 30to15 (allows more artifacts)
	}
	
// Reinforce tips
function Reinforce_tips()
	{
	run("Ridge Detection", "line_width=5.5 high_contrast=230 low_contrast=60 darkline correct_position extend_line method_for_overlap_resolution=SLOPE sigma=2.00 lower_threshold=0.68 upper_threshold=5.61 minimum_line_length="+Minimum_skeleton_area+" maximum="+Maximum_skeleton_area+"");
	run("Overlay Options...", "stroke=black width=0 fill=none apply");
	run("Flatten");
	run("8-bit");
	run("Remove Overlay");
	}
	
// Run unsharp mask
function Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area)
	{
	if(Run_unsharp_enable=="On")
		{
		run("Unsharp Mask...", "radius="+Minimum_skeleton_area+" mask=0.65");
		}
	}
	
//###### ANALYSE PARTICLE TYPE FUNCTIONS ################

	
// Get tryp shaped outlines										// this is mostly so that a uniform definition is used throughout the pipeline
function Get_tryp_shaped_outlines(masks)
	{
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area bounding");
	run("Analyze Particles...", "size="+Min_tryp_area+"-"+Max_tryp_area+" pixel circularity="+Circularity_range+" "+masks+" display exclude clear add");	
	}
	
// REOBTAIN Get tryp shaped outlines								// more relaxed perameters as this is post-curation									
function Reobtain_outlines(masks)
	{
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area bounding");
	run("Analyze Particles...", "size=[]"+masks+" display exclude clear add");	 // don't need to include limits if I've already decided the ROI is good.
	}

// Get outline fragments		
function Get_outline_fragments(masks)
	{
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area");
	run("Analyze Particles...", "size="+(Min_tryp_area/4)+"-"+Min_tryp_area+" pixel circularity=0.00-0.25 "+masks+" display exclude clear add"); // allow for larger fragments by changing /6 to /4
	}

// Get outline skeletons		
function Get_outline_skeletons(masks)
	{
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area");
	run("Analyze Particles...", "size="+Minimum_skeleton_area+"-"+Maximum_skeleton_area+" pixel circularity=0.00-0.10 "+masks+" display exclude clear");
	}
	
function Rebuild_skeletons(masks)
	{
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area");
	run("Analyze Particles...", "size=[] pixel circularity=[] show=Masks display exclude clear"); // skeleton area limits causing a problem
	}

// Get noise on nuclear channel		
function Get_noise_on_nuclear_channel(masks)
	{
	run("Make Binary");
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area");
	run("Analyze Particles...", "size="+(Kinetoplast_area_minimum/1.5)+"-"+Kinetoplast_area_minimum+" pixel circularity=0.25-1.0 "+masks+" display exclude clear add");
	}

// Get nuclear structures
function Get_nuclear_structures(masks)
	{
	run("Make Binary");
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area centroid");	
	run("Analyze Particles...", "size="+Kinetoplast_area_minimum+"-"+Nucleus_area_maximum+" pixel circularity=0.25-1.0 "+masks+" display exclude clear add");
	}
	
// Get oversize nuclear structures
function Get_oversize_nuclear_structures(masks)
	{
	run("Make Binary");
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area");		
	run("Analyze Particles...", "size="+Nucleus_area_maximum+"-"+(Nucleus_area_maximum*10)+" pixel circularity=0.25-1.0 display exclude clear add");
	}
	
// Get pyhtagorean distance
function Get_pythagorean_distance(x1, x2, y1, y2)
	{
	return sqrt(  ((x1-x2)*(x1-x2)) + ((y1-y2)*(y1-y2))  );
	}
	
function Get_curated_structures(masks)								// can remove all parameters as this is post-curation
	{
	run("Make Binary");
	run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");		// not square inches
	run("Set Measurements...", "area centroid");	
	run("Analyze Particles...", "size=[] pixel circularity=[] display exclude clear add");
	}
	
//###### ADDITIONAL FUNCTIONS ###########################

// Save log
function Save_log()
	{
	selectWindow("Log");
	saveAs("Text", Processed_directory+Run_start_time+"-Log.txt"); 			// This accounts for multiple/fragmented runs
	}
	
// End Image Analysis
function End_credits()
	{
	Save_log();
	Time_completed= Date_time_as_string(Time_completed);
	print("Process complete. Log saved. "+
		"All cells analysed and sorted. "+
		"Run ends "+Time_completed+". "+
		"Thank you for using TRYPANOSOME ANALYSIS SUITE version:"+Current_version+"");
	Close_open_images();
	showMessage("Process complete.\n"+
				"All cells analysed and sorted \n"+
				"Thank you for using TRYPANOSOME ANALYSIS SUITE version:"+Current_version+"");
	}

//Get Date and Time as a text string	
function Date_time_as_string(x)			//adapted from the Get Time imagej Macro example available at: https://imagej.nih.gov/ij/macros/GetDateAndTime.txt
	{	
	MonthNames = newArray("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
    getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
	TimeString = ""+dayOfMonth+""+MonthNames[month]+""+year+"_";
	if (hour<10) {TimeString = TimeString+"0";}
    TimeString = TimeString+hour+"";
    if (minute<10) {TimeString = TimeString+"0";}
    TimeString = TimeString+minute+"";
    if (second<10) {TimeString = TimeString+"0";}
    TimeString = TimeString+second;
	x=TimeString;
	return x;
	}
		
//################# TIDY BEFORE BEGINNING #####################################
//############################################################################
Close_open_images();
pipe = 1;
Run_start_time = Date_time_as_string(Run_start_time);
print("Run Starts: "+Run_start_time+"");
//################# GET WORKING DIRECTORY ###################################
// Ask for directory
// make/set directories for processed images
//############################################################################

directory = getDirectory("Choose a Directory");								// Ask for directory in which to operate	
  if (directory=="")														// Detect no valid selection
      exit("No selection");												// break
print("directory: "+directory+"");
	  
Processed_directory = directory+"Processed"+File.separator;					// Make Processed directory	
	File.makeDirectory(Processed_directory);								// variable >> Processed_directory
																			
Cells_directory = Processed_directory+"Cells"+File.separator;					// Make Cells directory	
	File.makeDirectory(Cells_directory);									// variable >> Cells_directory

Clean_singlets_directory = Cells_directory+"Clean singlets"+File.separator;		// Make directory for 1k1n nice cells
	File.makeDirectory(Clean_singlets_directory);							// variable >> Cells_directory
	File.append("Cell,Circularity,Solidity,Skeleton_area(pixels),Skeleton_length(pixels),Skeleton_length(µm),Cumulative_ridge_length(µm),No_Nuclei,No_Kinetoplasts,Nuclei_centroids_X[0],Nuclei_centroids_Y[0],Nuclei_to_skeleton(µm),Nuclei_to_nearest_end(µm),Kinetoplast_centroids_X[0],Kinetoplast_centroids_Y[0],Kinetoplast_to_skeleton(µm),Kinetoplast_to_nearest_end(µm),KN_along_skeleton(µm),KN_distance(µm), Skeleton_quality,\n", Clean_singlets_directory + "population data.txt");
	
Clean_dividers_directory = Cells_directory+"Clean dividers"+File.separator;		// Make directory for 2k2N nice cells
	File.makeDirectory(Clean_dividers_directory);								// variable >> Cells_directory

Cell_data_directory = Cells_directory+"Cell data"+File.separator;				// Make directory for 1k1n nice cells
	File.makeDirectory(Cell_data_directory);									// variable >> Cells_directory
	
Analysed_cells_directory = Cells_directory+"Analysed cells"+File.separator;		// Make directory for 1k1n nice cells
	File.makeDirectory(Analysed_cells_directory);								// variable >> Cells_directory
	File.append("Cell,Circularity,Solidity,Skeleton_area(pixels),Skeleton_length(pixels),Skeleton_length(µm),Cumulative_ridge_length(µm),No_Nuclei,No_Kinetoplasts,Nuclei_centroids_X[0],Nuclei_centroids_Y[0],Nuclei_to_skeleton(µm),Nuclei_to_nearest_end(µm),Kinetoplast_centroids_X[0],Kinetoplast_centroids_Y[0],Kinetoplast_to_skeleton(µm),Kinetoplast_to_nearest_end(µm),KN_along_skeleton(µm),KN_distance(µm), Skeleton_quality,\n", Analysed_cells_directory + "population data.txt");
	File.append("Cell,Step,Why_unusual,N,\n", Analysed_cells_directory + "Unusual_cells.txt"); //keep record of why any cells unusual
	
// Set record of manual curation	
if (Manually_curate_ROI==1 || Manually_curate_nuclearROI==1)
	{
	File.saveString(""+Manually_curate_ROI+"\n"+Manually_curate_nuclearROI+"", Processed_directory+"manual_curation.txt"); //not overly pretty, but allows pipeline to recall manual curation, even if run has been fragmented.
	}	
//################# RECURSE IN DIRECTORY #####################################
// Number of image sets can not be greater than number of files, 
// look for files beginning with number n, until n increases to number of file
//############################################################################

print ("For individual run settings, values are: Best_colour_channel, Best_subtract_background_radius, Best_anti_alias_gain. \n");

// Save settings to Processed directory
selectWindow("Log");
saveAs("Text", Processed_directory+Run_start_time+"Run_settings.txt");
  
//###### IF OUTLINE PROCESSING IS ENABLED #########
 
if(Process_outlines==1)
	{
	print("wwwwwwwwwwwwww PROCESSING OUTLINES wwwwwwwwwwwwww");
	list = getFileList(directory); Array.sort(list);							// Get all the files in the directory
	

// If need to determine best parameters for images or want to use selected settings 
	if(Use_existing_run_settings==0)
		{
		for (n=Starting_image; n<(10+Starting_image+list.length); n++) 	// Image sets start at 1, SS+ now allows for starting at different number									
			{															
			print("\nLooking for set:"+n+"");							// 

//################# OPEN FILE, SPLIT CHANNELS, DETERMINE BEST CHANNEL FOR OUTLINES #########
// Open file
// Split Channels
// Test each channel superficially for trypanosome sized things
// Determine best colour channel
//#########################################################################################

			for (b=0; b<Image_types_brightfield.length; b++)							// For the different kinds of brightfield images
				{
				print("Looking for:"+directory+n+""+Image_types_brightfield[b]+".tif");		// !! Diagnostic
				if(File.exists(directory+n+""+Image_types_brightfield[b]+".tif"))			// if file of (n) set and brightfield type exists
					{
					print(directory+n+""+Image_types_brightfield[b]+".tif - Found \n");

					// Auto channel determination
					if (Outline_channel_choice == "Auto")
						{
						print("Best channel analysis:");
						open(directory+n+""+Image_types_brightfield[b]+".tif");			// Open file
						if (Microscope_choice=="Lori's epiflourescent")				// only needed for these images
							{
							run("RGB Color");
							}
						run("Split Channels");									// Split channels		
						
						// Reset variables
						Channel_maximum = 0;
						Best_colour_channel = 5;								// SS+ set to 5 as 'none of the above', so can default to green later
						Channels_performance = newArray;
						
						// Find best channel
						for (c=0; c<Channels.length; c++)											// For each channel
							{
							selectWindow(""+n+""+Image_types_brightfield[b]+".tif ("+Channels[c]+")");		// Select window

							run("Subtract Background...", "rolling=15 light sliding");						// subtract background
							Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);
							Antialias(4);
							Basic_binary_processing("dark");											// binary processing
							Dilate_and_erode();													// try to join near fragments
							Get_tryp_shaped_outlines("");											// Run standard tryp shaped particle filter
							Channels_performance[c] = roiManager("count");							// Get number of things which pass test
							Close_image_by_title(""+n+""+Image_types_brightfield[b]+".tif ("+Channels[c]+")");
							Clear_ROI();															// Clean up analysis
							}
						Close_open_images();														// Should be unecessary, executed for workspace hygiene
						for (i=0; i<Channels_performance.length; i++) 									// figure out which channel did best
							{																		
							print("Channel: " + Channels[i] + " : " + Channels_performance[i]);		
							if(Channels_performance[i] > Channel_maximum && Channels_performance[i] <= (1.25*Max_cells_per_image))						
								{Channel_maximum = Channels_performance[i];Best_colour_channel = i;}
							}																		
						
						// If too many tryps are identified (Exceeds maximum number * 1.25), then set green as default channel.
						if (Best_colour_channel == 5)
							{
							print("Number of trypanosomes exceeds maximum parameters for each channel. Default best channel to green.\n");
							Best_colour_channel = 1;
							}
						print("Best channel: "+Channels[Best_colour_channel]+"\n");					
						File.append("Set: "+n+", outline best channel: "+Channels[Best_colour_channel]+"\n", Processed_directory+"Run_settings.txt");
						}
						
					// for set channels
					else if (Outline_channel_choice == "Red")
						{Best_colour_channel=0;}
					else if (Outline_channel_choice == "Green")
						{Best_colour_channel=1;}
					else if (Outline_channel_choice == "Blue")
						{Best_colour_channel=2;}

//################# DETERMINE BEST SUBTRACT BACKGROUND RADIUS #############
// Get best colour channel from before
// Rest a range of remove background radii (1-20)
// Sort for tryps, and things of sub tryp size
// Determine best radius, by which setting gives most tryps for fewest fragments
//############################################################################

					Retrieve_colour_channel_from_RGB_image(directory, ""+n+""+Image_types_brightfield[b]+".tif", Best_colour_channel);
					
					//reset variables				
					Best_subtract_background_radius = 0;								
					Radius_fragments = newArray;										
					Radius_trypanosomes = newArray;										
					Radius_calculated_array = newArray;									
					
					if (Outline_subtract_radius == "Auto")
						{
						print("\nFind best subtract background radius:");
						for (r=1; r<8; r++)												// test subtract background radius between 1 - 20 SS+ r<10 changed to r<8, radius between 1-16
							{
							selectWindow(n+""+Image_types_brightfield[b]+".tif ("+Channels[Best_colour_channel]+")");
							run("Duplicate...", "title=[radius-"+(r*2)+".tif]");					// duplicate contrast adjusted best channel
							selectWindow("radius-"+(r*2)+".tif");							// Select duplicate
							run("Subtract Background...", "rolling="+(r*2)+" light sliding");		// subtract background
							Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);
							Antialias(4);													
							Basic_binary_processing("dark");								// binary processing
							Dilate_and_erode();
							
							run("Duplicate...", "title=[radius-"+(r*2)+"fragments.tif]");			// duplicate the green channel to hoechst image
							Get_outline_fragments("");
							Radius_fragments[r] = roiManager("count");					// Get number of things which pass test
							Close_image_by_title("radius-"+(r*2)+"fragments.tif");				
							Clear_ROI();													
																							
							selectWindow("radius-"+(r*2)+".tif");								
							Get_tryp_shaped_outlines("");										
							Radius_trypanosomes[r] = roiManager("count");					// Get number of things which pass test
							Close_image_by_title("radius-"+(r*2)+".tif");						
							Clear_ROI();													
							}
						
						Close_open_images();											// should only have to close the split image channel of the brightfield image

						for (i=0; i<Radius_trypanosomes.length; i++) 						// For the information stored in the array
							{																
							if (0==Radius_trypanosomes[i] || 0==Radius_fragments[i])		//ratio meaningless if either of these values are 0, so have to factor in alternatives here.
								{if (0!=Radius_trypanosomes[i])
									{Radius_calculated_array[i]=Radius_trypanosomes[i];} 	// This section maximises the number of trypanosomes found, if number of fragments is 0
								else {Radius_calculated_array[i]=0;}
								}
							else{Radius_calculated_array[i]=(Radius_trypanosomes[i]/Radius_fragments[i]);}
							print("Radius:" + ((i+1)*2) + " Trypanosomes: " + Radius_trypanosomes[i] + " Fragments:" + Radius_fragments[i] + " Ratio:" +Radius_calculated_array[i]);
							}
							
						Fragments_trypanosome_factor = 0;									
						for (i=0; i<Radius_calculated_array.length; i++) 						// For the calculated array
							{														// - looking for lowest number
							if(Radius_calculated_array[i] > Fragments_trypanosome_factor && Radius_calculated_array[i] != 0 && Radius_trypanosomes[i] < (2.5*Max_cells_per_image)) //SS+ added requirement that there are not more than 2.5 times the maximum number of trypansomes expected
								{Fragments_trypanosome_factor = Radius_calculated_array[i]; Best_subtract_background_radius=((i+1)*2);}
							}		
						print("best radius: "+Best_subtract_background_radius+"\n");			//
						File.append("Set: "+n+", outline best radius: "+Best_subtract_background_radius+"\n", Processed_directory+"Run_settings.txt");
						}
					else
						{Best_subtract_background_radius = parseInt(Outline_subtract_radius);}

//###### ADJUST GAIN ##############################

					Retrieve_colour_channel_from_RGB_image(directory, ""+n+""+Image_types_brightfield[b]+".tif", Best_colour_channel);

					// Reset variables				
					Best_anti_alias_gain = 0;								
					anti_alias_fragments = newArray;										
					anti_alias_trypanosomes = newArray;										
					anti_alias_calculated_array = newArray;									
					
					
					if (Outline_anti_alias_gain == "Auto")
						{
						print("\nFind best gain for anti-alias:");
						for (r=1; r<8; r++)												// test subtract background radius between 1 - 20 SS+ r<10 changed to r<8, radius between 1-16
							{
							selectWindow(n+""+Image_types_brightfield[b]+".tif ("+Channels[Best_colour_channel]+")");
							run("Duplicate...", "title=[gain-"+r+".tif]");						// duplicate contrast adjusted best channel	
							
							selectWindow("gain-"+r+".tif");								// Select duplicate
							run("Subtract Background...", "rolling="+Best_subtract_background_radius+" light sliding");	// subtract background
							Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);
							Antialias(r);													
							Basic_binary_processing("dark");								// binary processing
							Dilate_and_erode();
							
							run("Duplicate...", "title=[gain-"+r+"fragments.tif]");				// duplicate the green channel to hoechst image
							Get_outline_fragments("");
							anti_alias_fragments[r] = roiManager("count");					// Get number of things which pass test
							Close_image_by_title("gain-"+r+"fragments.tif");				
							Clear_ROI();													
																							
							selectWindow("gain-"+r+".tif");									
							Get_tryp_shaped_outlines("");									
							anti_alias_trypanosomes[r] = roiManager("count");				// Get number of things which pass test
							Close_image_by_title("gain-"+r+".tif");							//
							Clear_ROI();													
							}
							
						for (i=0; i<anti_alias_trypanosomes.length; i++) 					// For the information stored in the array
							{
							if (0==anti_alias_fragments[i] || 0==anti_alias_trypanosomes[i])	// This section maximises the number of trypanosomes found, if number of fragments (and therefore ratio) is 0
								{
								if (0!=anti_alias_trypanosomes[i])
									{anti_alias_calculated_array[i]=anti_alias_trypanosomes[i];}
								else {anti_alias_calculated_array[i]=0;}
								}
							else{anti_alias_calculated_array[i]=(anti_alias_trypanosomes[i]/anti_alias_fragments[i]);}
							print("Gain:" + i + " Trypanosomes: " + anti_alias_trypanosomes[i] + " Fragments:" + anti_alias_fragments[i] + " Ratio:" +anti_alias_calculated_array[i]);
							}
							
						anti_alias_trypanosome_factor = 0;									
						for (i=0; i<anti_alias_calculated_array.length; i++) 					// For the calculated array
							{														// - looking for lowest number
							if(anti_alias_calculated_array[i] > anti_alias_trypanosome_factor && anti_alias_calculated_array[i] != 0 && anti_alias_trypanosomes[i] < (2.5*Max_cells_per_image)) 	// SS+ added requirement that there are not more than 2.5 times the maximum number of trypansomes expected
								{anti_alias_trypanosome_factor = anti_alias_calculated_array[i]; Best_anti_alias_gain=i;}
							}		
						print("best gain for anti alias: "+Best_anti_alias_gain+"\n");			
						File.append("Set: "+n+", outline best anti alias gain: "+Best_anti_alias_gain+"\n", Processed_directory+"Run_settings.txt");
							
						}
					else {Best_anti_alias_gain = parseInt(Outline_anti_alias_gain);}
					
					//Save run settings per image
					File.saveString(""+Best_colour_channel+"\n"+Best_subtract_background_radius+"\n"+Best_anti_alias_gain+"", Processed_directory+n+"run_settings.txt");
					}
				}
			
			}
		}
	Save_log();

//###### MAKING THE OUTLINE IMAGE #################		
		
// If using existing run settings, will skip to here.		
	
	print("\nMaking outline images");
	for (n=Starting_image; n<(10+Starting_image+list.length); n++) 				// Image sets start at 1, SS+ now allows for starting at different number									
		{
		pipe= 1;															// reset diagnostic image count
		for (b=0; b<Image_types_brightfield.length; b++)
			{
			if(File.exists(directory+n+""+Image_types_brightfield[b]+".tif"))
				{		

				// reset variables
				Best_colour_channel = 0;
				Best_subtract_background_radius = 0;
				Best_anti_alias_gain = 0;
				
				image_run_settings = File.openAsString(Processed_directory+n+"run_settings.txt"); 				// re-obtain run settings for this image from saved file
				image_run_settings_array = split(image_run_settings, "\n");
				Best_colour_channel = parseInt(image_run_settings_array[0]);
				Best_subtract_background_radius = parseInt(image_run_settings_array[1]);
				Best_anti_alias_gain = parseInt(image_run_settings_array[2]);		

				Retrieve_colour_channel_from_RGB_image(directory, ""+n+"bf.tif", Best_colour_channel);
				print("Making outline for image "+n+": \nSelecting best channel: "+Channels[Best_colour_channel]+"");	// Use best colour channel
				
				rename(n+"-outline.tif");										// rename		
				selectWindow(n+"-outline.tif");								// reacquire
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;		// take diagnostic snapshot pipe1
					
				if (Tip_reinforcement == "On")
					{
					Reinforce_tips();
					selectWindow(n+"-outline.tif"); close();
					selectWindow(n+"-outline-1.tif");
					rename(n+"-outline.tif");
					Take_diagnostic_image(Processed_directory, n, pipe); pipe++;	// take diagnostic snapshot pipe2
					}
				
				Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;		// take diagnostic snapshot pipe3
				
				selectWindow(n+"-outline.tif");
				saveAs("Tiff", Processed_directory+n+"-outline.tif");
				Close_open_images();
				}
			}
		}

//###### MANUAL CURATION OF TIP DRAWING ##########
	
	for (n=Starting_image; n<(10+Starting_image+list.length); n++)
		{
		pipe=4;
		for (b=0; b<Image_types_brightfield.length; b++)							// For the different kinds of brightfield images
			{
			print("Looking for:"+directory+n+""+Image_types_brightfield[b]+".tif");		// !! Diagnostic
			if(File.exists(directory+n+""+Image_types_brightfield[b]+".tif"))			// if file of (n) set and brightfield type exists
				{
				image_run_settings = File.openAsString(Processed_directory+n+"run_settings.txt");  				//re-obtain run settings for this image from saved file
				image_run_settings_array = split(image_run_settings, "\n");
				Best_colour_channel = parseInt(image_run_settings_array[0]);
				Best_subtract_background_radius = parseInt(image_run_settings_array[1]);
				Best_anti_alias_gain = parseInt(image_run_settings_array[2]);
				
				open(Processed_directory+n+"-outline.tif");
			
				if (Pause_for_tip_drawing=="On")
					{
					setTool("dropper");
					setForegroundColor(0, 0, 0);
					setTool("Pencil Tool");					
					run("Pencil Tool Options...", "brush=3");
					waitForUser("Manually correct flagella tips/fill voids, then press OK");
					print("Manual correction of flagella tips/ voids completed for image "+n+"");
					}
				
				run("Bandpass Filter...", "filter_large="+(Min_tryp_area/2)+" filter_small="+(Best_subtract_background_radius/4)+" suppress=None tolerance=90 autoscale saturate");
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;		// take diagnostic snapshot pipe4

				print("Using best subtract background radius: "+Best_subtract_background_radius+"");
				run("Subtract Background...", "rolling="+Best_subtract_background_radius+" light sliding");
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;		// take diagnostic snapshot pipe5
				
				Antialias(Best_anti_alias_gain);
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;		//pipe6
				
				run("Duplicate...", "title=["+n+"-brightfield]");					
				run("Invert");														
				saveAs("Tiff", Processed_directory+n+"-brightfield.tif"); 			
				
				selectWindow(n+"-outline.tif");
				
				setThreshold(0, 90);										// one of the last remaining numerical variables- probably need tuning	SS+ max taken up from 70 to 90
				run("Apply LUT");
				Dilate_and_erode();													
				run("Fill Holes");
				
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;		// pre-filtering outlines image essentially pipe7
				run("Make Binary");
				Get_tryp_shaped_outlines("show=Masks");						// final selection of cells
				saveAs("Tiff", Processed_directory+n+"-outline.tif"); 				// save n-outline.tif
				print("Saved as "+Processed_directory+n+"-outline.tif");			// write to log
				
				if(0!=roiManager("count"))									// If cells have been found
					{
					print("Number of trypanosomes detected: "+roiManager("count"));
					File.append("Set: "+n+", Number of trypanosomes: "+roiManager("count")+"\n", Processed_directory+"Run_settings.txt");
					run("Distribution...", "parameter=Area or=15 and="+Min_tryp_area+"-"+Max_tryp_area+"");	// make a graph of their area
					saveAs("Tiff", Processed_directory+n+"-outline histogram.tif");							// save graph as .tif
					Clear_ROI();																	// tidy up
					}
				selectWindow(n+"-outline.tif");														// select blue
				
				// Generate skeletons
				rename(n+"-skeleton");
				run("Convert to Mask");												// mask														
				run("Make Binary");												// make binary
				run("Skeletonize");													// skeletonize
				for (a = 0; a < 2; a++)											// set cycles of iterative skeleton pruning
					{run("Prune skeleton", "threshold="+Prune_skeleton_threshold);run("Skeletonize");}		
				Get_outline_skeletons("show=Masks");								
				saveAs("Tiff", Processed_directory+n+"-skeleton.tif"); 				
				
				if(0!=roiManager("count"))											// if there skeletons which pass
					{
					run("Distribution...", "parameter=Area or=15 and="+Minimum_skeleton_area+"-"+Maximum_skeleton_area+"");		// make a graph
					saveAs("Tiff", Processed_directory+n+"-skeleton histogram.tif");											// save as .tif
					Clear_ROI();													 
					}	
				Close_open_images();												// tidy up
				}
			}
		}
	}
Save_log();

//###### DETERMINING NUCLEAR STRUCTURES ################
//########################################################
 
 if(Process_nuclear_structures==1)
	{
	print("\nwwwwwwwwww PROCESSING NUCLEAR STRUCTURES wwwwwwwwww");	
	list = getFileList(directory); Array.sort(list);							// Get all the files in the directory
	Close_open_images();
	
	for (n=Starting_image; n<(10+Starting_image+list.length); n++) 		// Default n=1 SS+ allows for the fact that might not always start at 1			
		{															
		print("\nLooking for set:"+n+"");							 
		pipe= 5;													// reset diagnostic image count
		
		for (b=0; b<Image_types_nuclear.length; b++)					// For the different kinds of brightfield images
			{
			//print("Looking for Nuclear strain type:"+Image_types_nuclear[b]+"");	// !! Diagnostic
			//print("Looking for:"+directory+n+""+Image_types_nuclear[b]+".tif");		// !! Diagnostic
			if(File.exists(directory+n+""+Image_types_nuclear[b]+".tif"))			// if file of (n) set and brightfield type exists
				{
				print(directory+n+""+Image_types_nuclear[b]+".tif - Found");
			
//###### DETERMINE BEST CHANNEL FOR NUCLEAR ANALYSIS ########
//###########################################################			
				if (Nuclear_channel_choice == "Auto")
					{
			
					print("\nBest colour channel analysis:");
					
					//reset variables
					Noise_of_nuclear_structure_population = newArray; 
					Nuclear_structure_population = newArray; 
					Oversize_of_nuclear_structure_population = newArray; 
					Nuclear_structure_enrichment = newArray; 
					Nuclear_structures_to_noise = 0;
					
					open(directory+n+""+Image_types_nuclear[b]+".tif");						// Open file
					run("Split Channels");												// Split channels		
					
					// Find best channel
					for (c=0; c<Channels.length; c++)									// For each channel
						{
						print("Testing: "+Channels[c]+"");
						selectWindow(n+""+Image_types_nuclear[b]+".tif ("+Channels[c]+")");	// Select window

						run("8-bit");
						Reduce_Hoechst_stain_noise(6);
						run("Invert");
						
						selectWindow(n+""+Image_types_nuclear[b]+".tif ("+Channels[c]+")");
						run("Duplicate...", "title=["+n+"-noise.tif]");							// duplicate to look for noise		
						Get_noise_on_nuclear_channel("");
						Noise_of_nuclear_structure_population[c] = roiManager("count");		// Get number of things which pass test
						close(); Clear_ROI(); 				
						
						selectWindow(n+""+Image_types_nuclear[b]+".tif ("+Channels[c]+")");
						run("Duplicate...", "title=["+n+"-nuclear structures.tif]");				// duplicate to look for nuclear structures	
						Get_nuclear_structures("");
						Nuclear_structure_population[c] = roiManager("count");				// Get number of things which pass test
						close(); Clear_ROI();
						
						selectWindow(n+""+Image_types_nuclear[b]+".tif ("+Channels[c]+")");
						run("Duplicate...", "title=["+n+"-oversize artifacts.tif]");				// duplicate to look for oversize blobs		
						Get_oversize_nuclear_structures("");
						Oversize_of_nuclear_structure_population[c] = roiManager("count");		// Get number of things which pass test
						close(); Clear_ROI();

						if(0==(Noise_of_nuclear_structure_population[c] + Oversize_of_nuclear_structure_population[c]))
							{Nuclear_structure_enrichment[c]=0;}
						else
							{Nuclear_structure_enrichment[c] = Nuclear_structure_population[c] - (0.5*( Noise_of_nuclear_structure_population[c] + Oversize_of_nuclear_structure_population[c] ));}
						print("Noise: "+Noise_of_nuclear_structure_population[c]+" Structures: "+Nuclear_structure_population[c]+" Oversize artifacts: "+Oversize_of_nuclear_structure_population[c]+" Enrichment: "+Nuclear_structure_enrichment[c]);
						}
					
					for (c=0; c<Nuclear_structure_enrichment.length; c++)					
						{																	
						if(Nuclear_structure_enrichment[c]>Nuclear_structures_to_noise)		
							{Nuclear_structures_to_noise = Nuclear_structure_enrichment[c]; Best_colour_channel_for_nuclear_structures = c;}
						else if(0==Nuclear_structure_enrichment[c])
							{Best_colour_channel_for_nuclear_structures = 2;}				//This should mean that if all the channels end up with an 'enrichment' of zero, the default will be blue (which is most likely for the nuclear stains we use).
						}																
					
					print("Best channel for nuclear structure discrimination is: "+Channels[Best_colour_channel_for_nuclear_structures]+"\n");
					Close_open_images();
					}
					
//###### MANUAL NUCLEAR CHANNEL SELECT #####################
					
				else if (Nuclear_channel_choice == "Red"){Best_colour_channel_for_nuclear_structures=0;}
				else if (Nuclear_channel_choice == "Green"){Best_colour_channel_for_nuclear_structures=1;}
				else if (Nuclear_channel_choice == "Blue"){Best_colour_channel_for_nuclear_structures=2;}

//###### DETERMINE BEST GAIN #################################

				Retrieve_colour_channel_from_RGB_image(directory, ""+n+""+Image_types_nuclear[b]+".tif", Best_colour_channel_for_nuclear_structures);
				
				// Reset variables
				Noise_of_nuclear_structure_population = newArray; 
				Nuclear_structure_population = newArray; 
				Oversize_of_nuclear_structure_population = newArray; 
				Nuclear_structure_enrichment = newArray; 
				Nuclear_structures_to_noise = -1000;
				Best_hoechst_background_reduction_gain = 0;				
				
				if (Nuclear_stain_gain == "Auto")
					{				
					// Find best gain
					for (c=1; c<10; c++)													// For gain 1-9
						{
						print("Testing reduce bakground gain: "+c+"");
						selectWindow(n+""+Image_types_nuclear[b]+".tif ("+Channels[Best_colour_channel_for_nuclear_structures]+")");	// Select window
						run("Duplicate...", "title=[reduce background gain x"+c+".tif]");	

						run("8-bit");
						Reduce_Hoechst_stain_noise(c);
						run("Invert");
						
						selectWindow("reduce background gain x"+c+".tif");
						run("Duplicate...", "title=["+n+"-noise.tif]");								// duplicate to look for noise		
						Get_noise_on_nuclear_channel("");
						Noise_of_nuclear_structure_population[c] = roiManager("count");			// Get number of things which pass test
						close(); Clear_ROI(); 				
						
						selectWindow("reduce background gain x"+c+".tif");
						run("Duplicate...", "title=["+n+"-nuclear structures.tif]");					// duplicate to look for nuclear structures	
						Get_nuclear_structures("");
						Nuclear_structure_population[c] = roiManager("count");					// Get number of things which pass test
						//Take_diagnostic_image(Processed_directory, n, pipe); pipe++;				// Helpful for debugging channel selection
						close(); Clear_ROI();
						
						selectWindow("reduce background gain x"+c+".tif");
						run("Duplicate...", "title=["+n+"-oversize artifacts.tif]");					// duplicate to look for oversize blobs		
						Get_oversize_nuclear_structures("");
						Oversize_of_nuclear_structure_population[c] = roiManager("count");			// Get number of things which pass test
						close(); Clear_ROI();

						if(0==(Noise_of_nuclear_structure_population[c] + Oversize_of_nuclear_structure_population[c]))
							{Nuclear_structure_enrichment[c]=0;}
						else
							{Nuclear_structure_enrichment[c] = Nuclear_structure_population[c] - (0.5*( Noise_of_nuclear_structure_population[c] + Oversize_of_nuclear_structure_population[c] ));}
						print("Noise: "+Noise_of_nuclear_structure_population[c]+" Structures: "+Nuclear_structure_population[c]+" Oversize artifacts: "+Oversize_of_nuclear_structure_population[c]+" Enrichment: "+Nuclear_structure_enrichment[c]);
						}

					for (c=0; c<Nuclear_structure_enrichment.length; c++)					
						{																	
						if(Nuclear_structure_enrichment[c]>Nuclear_structures_to_noise && Nuclear_structure_enrichment[c]<(3*Max_cells_per_image))			//SS+ added check to stop results that have ridiculously high enrichment due to 'speckles', it should never be more than 3 times the maximum expected number of cells	
							{Nuclear_structures_to_noise = Nuclear_structure_enrichment[c]; Best_hoechst_background_reduction_gain = c;}
						}																	
					
					print("Best gain for hoechst background reduction: "+Best_hoechst_background_reduction_gain+"");
					Close_open_images();
					}
				else {Best_hoechst_background_reduction_gain = parseInt(Nuclear_stain_gain);}
				
//###### PROCESS NUCLEAR STRUCTURES #######################

				print("\n Processing nuclear structures");

				Retrieve_colour_channel_from_RGB_image(directory, ""+n+""+Image_types_nuclear[b]+".tif", Best_colour_channel_for_nuclear_structures);
				rename(n+"-nuclear structures.tif");
				saveAs("Tiff", Processed_directory+n+"-nuclear structures.tif"); 	
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;
				
				selectWindow(n+"-nuclear structures.tif");	
				Reduce_Hoechst_stain_noise(Best_hoechst_background_reduction_gain);
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;

				selectWindow(n+"-nuclear structures.tif");	
				run("Invert");
				Basic_binary_processing("light");
				run("Watershed");
				Take_diagnostic_image(Processed_directory, n, pipe); pipe++;
								
				selectWindow(n+"-nuclear structures.tif");						
				run("Duplicate...", "title=["+n+"-nuclei.tif]");					// duplicate the green channel to hoechst image
				run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");	// not square inches
				run("Set Measurements...", "area centroid");					
				run("Analyze Particles...", "size="+Nucleus_area_minimum+"-"+Nucleus_area_maximum+" pixel circularity=0.3-1.0 show=Masks display exclude clear add"); 	//SS+ change pixel circularity min from 0.4 to 0.3
				saveAs("Tiff", Processed_directory+n+"-nuclei.tif"); 			
				
				if (0==roiManager("count"))
					{
					print("No nuclei found.");
					selectWindow(n+"-nuclear structures.tif");
					run ("Duplicate...", "title="+n+"-nuclei_ROIs");
					makeRectangle(0,0,1,1);  							// if no nuclei, still need an overlay for processing later
					roiManager("Add");
					run("From ROI Manager");
					saveAs("Tiff", Processed_directory+n+"-nuclei_ROIs.tif");
					close();
					print("saving placeholder image for nuclear ROIs of set "+n+".");
					Clear_ROI();															
					}
				if(0!=roiManager("count"))										
					{
					print("Number of nuclei found: "+roiManager("count"));		
					run("Distribution...", "parameter=Area or=20 and="+Nucleus_area_minimum+"-"+Nucleus_area_maximum+"");	
					saveAs("Tiff", Processed_directory+n+"-nuclei histogram.tif");					
					nuclei_ROIs = newArray;							//Define new array, in which to store the nuclei ROIs
					for (i=0; i<roiManager("count"); ++i){nuclei_ROIs[i]=i;}	// work through ROI manager, and for each entry add to array (No's [1,3,4,5,17,18] etc)
					selectWindow(n+"-nuclear structures.tif");
					run ("Duplicate...", "title="+n+"-nuclei_ROIs");
					run("Select All");
					run("Clear", "slice");
					roiManager("Select", nuclei_ROIs);// Select here works with plural by accepting an array which we make above
					run("Fill", "slice");
					run("From ROI Manager");							// save ROIs as overlay 
					saveAs("Tiff", Processed_directory+n+"-nuclei_ROIs.tif");					// nuclei_ROIs saved as overlay
					run("Select All");
					run("Invert");
					saveAs("Tiff", Processed_directory+n+"-nuclei.tif");		
					close();
					print("saving nuclear ROIs for set "+n+".");
					Clear_ROI();														
					}
									
				selectWindow(n+"-nuclear structures.tif");					
				run("Duplicate...", "title=["+n+"-kinetoplasts.tif]");			// duplicate the green channel to hoechst image
				run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");	// not square inches
				run("Set Measurements...", "area centroid");					
				run("Analyze Particles...", "size="+Kinetoplast_area_minimum+"-"+Kinetoplast_area_maximum+" pixel circularity=0.3-1.0 show=Masks display exclude clear add"); 	//SS+ change pixel circularity min from 0.4 to 0.3
				saveAs("Tiff", Processed_directory+n+"-kinetoplasts.tif"); 		
				
				if (0==roiManager("count"))
					{
					print("No kinetoplasts found.");
					selectWindow(n+"-nuclear structures.tif");
					run ("Duplicate...", "title="+n+"-kinetoplast_ROIs");
					makeRectangle(0,0,1,1); 							// If no kinetoplasts, still need an overlay for processing later
					roiManager("Add");
					run("From ROI Manager");
					saveAs("Tiff", Processed_directory+n+"-kinetoplast_ROIs.tif");
					close();
					print("saving placeholder image for kinetoplast ROIs of set "+n+".");
					Clear_ROI();															
					}
				if (0!=roiManager("count"))										
					{
					print("Number of kinetoplasts found: "+roiManager("count"));					
					run("Distribution...", "parameter=Area or=20 and="+Kinetoplast_area_minimum+"-"+Kinetoplast_area_maximum+"");	
					saveAs("Tiff", Processed_directory+n+"-kinetoplasts histogram.tif");		
					kinetoplast_ROIs = newArray;									// define new array, in which to store the kinetoplast ROIs
					for (i=0; i<roiManager("count"); ++i){kinetoplast_ROIs[i]=i;}			// work through ROI manager, and for each entry add to array (No's [1,3,4,5,17,18] etc)
						// Select here works with plural by accepting an array which we make above
					selectWindow(n+"-nuclear structures.tif");
					run ("Duplicate...", "title="+n+"-kinetoplast_ROIs");
					run("Select All");
					run("Clear", "slice");
					roiManager("Select", kinetoplast_ROIs);// Select here works with plural by accepting an array which we make above
					run("Fill", "slice");
					run("From ROI Manager");										// save ROIs as overlay 
					saveAs("Tiff", Processed_directory+n+"-kinetoplast_ROIs.tif");			// kinetoplast_ROIs saved as overlay
					run("Select All");
					run("Invert");
					run("8-bit");
					saveAs("Tiff", Processed_directory+n+"-kinetoplasts.tif");	
					close();	
					print("saving kinetoplast ROIs for set "+n+".");
					Clear_ROI(); 														
					}
			
				Close_open_images();	
				Clear_non_image_windows();
				}
			}
		}
	}
Save_log();
Close_open_images();	
Clear_non_image_windows();

//###### GENERATE MULTICOLOUR COMPOSITE ########
if(Generate_multicolour_composite==1)
	{
	pipe = 12;
	print("wwwwwwwwww GENERATE MULTICOLOUR COMPOSITE wwwwwwwwww\n");	
	list = getFileList(directory); Array.sort(list);							// Get all the files in the directory
	for (n=Starting_image; n<(10+Starting_image+list.length); n++) 		// Image sets start at 1, SS+ now allows for starting at different number
		{														
		print("Looking for set:"+n+"");
		if(File.exists(Processed_directory+n+"-outline.tif"))
			{
			if(File.exists(Processed_directory+n+"-skeleton.tif"))
				{
				if(File.exists(Processed_directory+n+"-brightfield.tif"))
					{
					if(File.exists(Processed_directory+n+"-nuclei.tif"))
						{	
						if(File.exists(Processed_directory+n+"-kinetoplasts.tif"))
							{
							open(Processed_directory+n+"-outline.tif");			run("Find Edges");	// Get outline
							open(Processed_directory+n+"-nuclei.tif"); 			run("Find Edges");	// Get outline
							open(Processed_directory+n+"-kinetoplasts.tif"); 	run("Find Edges");	// Get outline
							open(Processed_directory+n+"-skeleton.tif");						// Skeleton already an outline
							
							// if window skeleton size is not the same as outlines (for some reason this happens occassionally) resize so that all windows same size.		
							selectWindow(""+n+"-outline.tif");	
							outline_width=getWidth;
							outline_height=getHeight;
							selectWindow(""+n+"-skeleton.tif");	
							skeleton_width=getWidth;
							if(skeleton_width!=outline_width)
								{
								run("Size...", "width="+outline_width+" height="+outline_height+" average interpolation=Bilinear");
								};
							
							open(directory+n+"bf.tif"); run("8-bit");								// Produce a minimally processed brightfield, 8 bit
							
							Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);			// Unsharp
							run("Divide...", "value=4");										// Make dark
							
							run("Merge Channels...", "c3="+n+"-outline.tif c2="+n+"-nuclei.tif c1="+n+"-kinetoplasts.tif c7="+n+"-skeleton.tif c4="+n+"bf.tif create");
							run("Stack to RGB");
							saveAs("Tiff", Processed_directory+n+"-composite.tif"); 	
							run("Save", "save="+Processed_directory+n+"-pipe"+pipe+".tif");		// take diagnostic snapshot
							print("Composite for set "+n+" made");
							Close_open_images();
							}
						}
					// if no nuclear information, still want a composite available
					else
						{
						open(Processed_directory+n+"-outline.tif"); run("Find Edges");				// Get outline
						open(Processed_directory+n+"-skeleton.tif");
						
						// if window skeleton size is not the same as outlines (for some reason this happens occassionally) resize so that all windows same size.		
						selectWindow(""+n+"-outline.tif");	
						outline_width=getWidth;
						outline_height=getHeight;
						selectWindow(""+n+"-skeleton.tif");	
						skeleton_width=getWidth;
						if(skeleton_width!=outline_width)
							{
							run("Size...", "width="+outline_width+" height="+outline_height+" average interpolation=Bilinear");
							}						
						
						open(directory+n+"bf.tif"); run("8-bit");									// Produce a minimally processed brightfield, 8 bit
							
						Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);				// Unsharp
						run("Divide...", "value=4");											// Make dark
						
						run("Merge Channels...", "c3="+n+"-outline.tif c7="+n+"-skeleton.tif c4="+n+"bf.tif create");
						run("Stack to RGB");
						saveAs("Tiff", Processed_directory+n+"-composite.tif"); 	
						run("Save", "save="+Processed_directory+n+"-pipe"+pipe+".tif");			// take diagnostic snapshot
						print("Skeleton-only composite for set "+n+" made");
						Close_open_images();		
						}
					}
				}
			}
		}
	}

//###### PREPARE CELL STACKS #####################
//################################################

if(Prepare_cell_stacks==1 && Start_post_manual==0) 					// Need to be able to skip if starting after manual step
	{
	print("wwwwwwwwww PREPARE CELL STACKS wwwwwwwwww\n");				
	list = getFileList(directory); Array.sort(list);							// Get all the files in the directory
		for (n=Starting_image; n<(10+Starting_image+list.length); n++) 	// Image sets start at 1, SS+ now allows for starting at different number and allows for 10 missing images before thinks its reached the total
		{																
		print("Looking for "+n+"-outline.tif");							// Diagnostic
		if(File.exists(Processed_directory+n+"-outline.tif") && File.exists(Processed_directory+n+"-composite.tif"))
			{				
			columns = 1;
			print("Found "+n+"-outline.tif");							// Diagnostic
			open(Processed_directory+n+"-outline.tif");					// Open file
			rename("outline");											
			run("Convert to Mask");									// Mask														
			run("Make Binary");									// Make binary
			Get_tryp_shaped_outlines("");							// NB keep ROI


//######  GET ORIGINAL FILES FOR EACH SET ###########
			
			for (i=0; i<Image_types.length; i++)						// Open all raw image types in set n
				{
				if(File.exists(directory+n+""+Image_types[i]+".tif"))	
					{open(directory+n+""+Image_types[i]+".tif");	rename(""+Image_types[i]+"");	columns++;}
				}

			if(isOpen("bf"))	{invert;}								// Black background helpful
				
//###### GET PROCESSED IMAGE PRODUCTS ###########		

			if(File.exists(Processed_directory+n+"-brightfield.tif"))		{open(Processed_directory+n+"-brightfield.tif");		rename("brightfield");	columns++;}
			if(File.exists(Processed_directory+n+"-skeleton.tif"))		{open(Processed_directory+n+"-skeleton.tif");		rename("skeleton");	columns++;}
			if(File.exists(Processed_directory+n+"-nuclei.tif"))			{open(Processed_directory+n+"-nuclei.tif");			rename("nuclei");		columns++;}
			if(File.exists(Processed_directory+n+"-kinetoplasts.tif"))	{open(Processed_directory+n+"-kinetoplasts.tif");	rename("kinetoplasts");	columns++;}
			if(File.exists(Processed_directory+n+"-composite.tif"))		{open(Processed_directory+n+"-composite.tif");		rename("composite");	columns++;}
			else{
				if(isOpen("h"))
					{
					selectWindow("h");
					}
				}
			run("Images to Stack", "name=Stack use");				// images to stack, name from n
			run("Reverse");										// Just so composite is displayed as thumbnail, disable if outline preferred
			saveAs("Tiff", Processed_directory+n+"-stackROI.tif");
			
			if(File.exists(Processed_directory+n+"-composite.tif"))
				{open(Processed_directory+n+"-composite.tif");}			// Open second copy for a review image

//###### MANUAL CURATION OF OUTLINES #############

			if(Manually_curate_ROI==1 && File.exists(Processed_directory+n+"-composite.tif"))
				{
				waitForUser("proceed to manually curate ROI for outlines by going through ROI entries whilst looking at composite, delete as appropiate, then press OK");
				Dialog.create("Drift Control");
				Dialog.addMessage(
					"If using nuclear images, check for drift.\n"+
					"Do the outlines and nuclear structures line up correctly?\n"+
					"If not, deselect the box below to remove nuclear layer from cell extraction process.");
				Dialog.addCheckbox("Process all available layers? ", true);
				Dialog.show();
				Bypass_drift_control = Dialog.getCheckbox();
				if (Bypass_drift_control==1)
					{
					print("No drift detected in image, process all available layers for set "+n+"");
					selectWindow(n+"-composite.tif");close();
					selectWindow(n+"-stackROI.tif");
					run("Stack to Images");
					}
				else {
					print("Drift detected, removing nuclear channel from cell extraction for set "+n+"");
					selectWindow(n+"-composite.tif");close();
					selectWindow(n+"-stackROI.tif");
					run("Stack to Images");
					if(isOpen("kinetoplasts")){	close(); 	File.rename(Processed_directory+n+"-kinetoplasts.tif", Processed_directory+n+"kinetoplasts_drift.tif"); }
					if(isOpen("nuclei")) {		close();	File.rename(Processed_directory+n+"-nuclei.tif", Processed_directory+n+"nuclei_drift.tif"); }
					}		
				if(isOpen("outline"))		// if we are manually curating, we're going to be using the new ROIs as outlines, so want a blank outline.tif to select from
					{
					run("Select All");
					run("Clear", "slice");
					run("Invert");
					run("8-bit");
					}					
				if(0!=roiManager("count"))
					{
					print("Remaining trypanosomes: "+roiManager("count"));		// Lists number of entries in ROI manager
					ROIs = newArray;										// Define new array, in which to store the remaining selections
					for (i=0; i<roiManager("count"); ++i){ROIs[i]=i;}				// work through ROI manager, and for each entry add to array (No's [1,3,4,5,17,18] etc)
					roiManager("Select", ROIs);								// Select here works with plural by accepting an array which we make above
					
					if (1<roiManager("count"))								// If there is more than one result
						{roiManager("Combine");}							// logically combine ROIS (ie, OR)
					run("Clear Outside");									// Clear everything we did not choose to accept from the outlines sliding
					run("Make Binary");									// Make binary in preparation for reaquisition
					Reobtain_outlines("");									// re-run outlines, so new ROI is numbered rationally
					run("Duplicate...", "title="+n+"-ROIs");
					run("From ROI Manager");								// save ROIs as overlay 
					saveAs("Tiff", Processed_directory+n+"-ROIs.tif");
					run("Images to Stack", "name=Stack use");				// reform stack
					saveAs("Tiff", Processed_directory+n+"-stackROI.tif");
					print("Manual curation of outline ROIs completed for set "+n+"");
					}
				else 
					{
					print("No remaining trypanosomes");						// Nothing left in ROI
					File.saveString("Image "+n+" did not contain any trypanosomes, or was skipped during this run.", Processed_directory+n+"skip.txt");
					if(isOpen("outline"))	
						{
						selectWindow("outline");
						makeRectangle(0,0,1,1);  							// If no outline, still need an overlay for processing later
						roiManager("Add");
						run("From ROI Manager");
						saveAs("Tiff", Processed_directory+n+"-stackROI.tif");
						run("Select All");									// Select all
						run("Clear", "slice");								// Clear all
						}
					}
				Clear_ROI();
				Close_open_images();

//###### MANUAL CURATION OF NUCLEAR STRUCTURES #############

				if(File.exists(Processed_directory+n+"nuclei_drift.tif"))
					{
					print("Drift detected, skipping curation of nuclear structures.");
					}
				else if (Manually_curate_nuclearROI==1)
					{
					if( File.exists(Processed_directory+n+"-stackROI.tif"))
						{
						if (File.exists(Processed_directory+n+"-nuclei_ROIs.tif"))
							{
							open(Processed_directory+n+"-nuclei_ROIs.tif");
							run("To ROI Manager");
							open(Processed_directory+n+"-stackROI.tif");
							
							
							waitForUser("proceed to manually curate nuclear ROIs by going through ROI entries whilst looking at composite, delete or add ROIs as appropiate, then press OK");
							if(0!=roiManager("count"))
								{	
								print("Manual curation of nuclei ROIs completed for set "+n+"");								
								print("Remaining nuclei: "+roiManager("count"));			// Lists number of entries in ROI manager
								nuclei_ROIs = newArray;							// Define new array, in which to store the remaining selections
								for (i=0; i<roiManager("count"); ++i){nuclei_ROIs[i]=i;}	// Work through ROI manager, and for each entry add to array (No's [1,3,4,5,17,18] etc)
								roiManager("Select", nuclei_ROIs);					// Select here works with plural by accepting an array which we make above
								selectWindow(n+"-nuclei_ROIs.tif");
								run("From ROI Manager");							// Save ROIs as overlay 
								saveAs("Tiff", Processed_directory+n+"-nuclei_ROIs.tif");
								close();
								// Now we're going to make sure the nucleus images correspond to these curated nuclei_ROIs
								if(File.exists(Processed_directory+n+"-nuclear structures.tif"))
									{
									open (Processed_directory+n+"-nuclear structures.tif");
									
									run ("Duplicate...", "title="+n+"-nuclei_ROIs");
									run("Select All");
									run("Clear", "slice");
									roiManager("Select", nuclei_ROIs);				
									roiManager("Fill");
									roiManager("Draw");
									run("From ROI Manager");	
									run("Select All");
									run("Invert");
									rename("nuclei");
									saveAs("Tiff", Processed_directory+n+"-nuclei.tif");
									close();
									selectWindow(n+"-nuclear structures.tif");
									close();
									}
								}
							else 
								{ 
								print("No remaining nuclei");	
								if(File.exists(Processed_directory+n+"-nuclei.tif"))
									{
									open(Processed_directory+n+"-nuclei.tif");
									run("Select All");
									run("Clear");
									saveAs("Tiff", Processed_directory+n+"-nuclei.tif");
									print("Manual curation of nuclei ROIs completed for set "+n+", no nuclei remaining.");
									}
								}
							Clear_ROI();
							}
						if(File.exists(Processed_directory+n+"-kinetoplast_ROIs.tif"))
							{
							open(Processed_directory+n+"-kinetoplast_ROIs.tif");
							run("To ROI Manager");
							open(Processed_directory+n+"-stackROI.tif");
							
							
							waitForUser("proceed to manually curate kinetoplast ROIs by going through ROI entries whilst looking at composite, delete or add ROIs as appropiate, then press OK");
							if(0!=roiManager("count"))
								{
								print("Manual curation of kinetoplast ROIs completed for set "+n+"");
								print("Remaining kinetoplasts: "+roiManager("count"));		// Lists number of entries in ROI manager
								kinetoplast_ROIs = newArray;							// Define new array, in which to store the remaining selections
								for (i=0; i<roiManager("count"); ++i){kinetoplast_ROIs[i]=i;}	// work through ROI manager, and for each entry add to array (No's [1,3,4,5,17,18] etc)
								roiManager("Select", kinetoplast_ROIs);					// Select here works with plural by accepting an array which we make above
								selectWindow(n+"-kinetoplast_ROIs.tif");
								run("From ROI Manager");							// save ROIs as overlay 
								saveAs("Tiff", Processed_directory+n+"-kinetoplast_ROIs.tif");
								close();
								// now we're going to make sure the kinetoplast images correspond to these curated kinetoplast_ROIs
								if(File.exists(Processed_directory+n+"-nuclear structures.tif"))
									{
									open (Processed_directory+n+"-nuclear structures.tif");
									run("Select All");
									run("Clear", "slice");
									roiManager("Select", kinetoplast_ROIs);
									roiManager("Fill");
									roiManager("Draw");
									run("Select All");
									run("Invert");
									run("8-bit");
									rename("kinetoplasts");
									saveAs("Tiff", Processed_directory+n+"-kinetoplasts.tif");
									Close_open_images();
									}
								}
							else 
								{
								print("No remaining kinetoplasts");	
								if(File.exists(Processed_directory+n+"-kinetoplasts.tif"))
									{
									open(Processed_directory+n+"-kinetoplasts.tif");
									run("Select All");
									run("Clear");
									saveAs("Tiff", Processed_directory+n+"-kinetoplasts.tif");
									print("Manual curation of kinetoplast ROIs completed for set "+n+", no kinetoplasts remaining.");
									}
								}
							}
					Clear_ROI();
					Close_open_images();
						}
					}	
				}	
			}
		
			else {print("Failed to find "+n+"-outline.tif");}			// Stack fails to contain outline? Possibility if adding new ROI, could ask it to reaquire from stack
			Close_open_images();
			Clear_non_image_windows();
		}
	}
	

//###### REGENERATE MULTICOLOUR COMPOSITE WITH MANUAL CORRECTIONS ##############
		
if(Start_post_manual==1 || Manually_curate_ROI==1)						// This is an OR logical statement, so will proceed if either statements are correct 
	{
	pipe = 13;
	print("wwwwwwwwww REGENERATE MULTICOLOUR COMPOSITE WITH MANUAL CORRECTIONS wwwwwwwwww\n");	//
	list = getFileList(directory); Array.sort(list);								// Get all the files in the directory
	for (n=Starting_image; n<(10+Starting_image+list.length); n++) 			// Image sets start at 1, SS+ now allows for starting at different number
		{															
		print("Looking for set:"+n+"");
		if(File.exists(Processed_directory+n+"-ROIs.tif"))
			{
			if(File.exists(Processed_directory+n+"-skeleton.tif"))
				{
				if(File.exists(Processed_directory+n+"-brightfield.tif"))
					{
					if(File.exists(Processed_directory+n+"-nuclei.tif"))
						{	
						if(File.exists(Processed_directory+n+"-kinetoplasts.tif"))
							{
							open(Processed_directory+n+"-ROIs.tif");	
							rename(n+"-outline.tif");
							run("To ROI Manager");
							roiManager("Show All without labels"); 
							outline_ROIs = newArray;
							for (i=0; i<roiManager("count"); ++i){outline_ROIs[i]=i;}
							selectWindow(n+"-outline.tif");
							run("Select All");
							run("Clear", "slice");
							roiManager("Select", outline_ROIs);
							roiManager("Fill");
							roiManager("Draw");
							run("Invert");
							saveAs("Tiff", Processed_directory+n+"-outline.tif");
														
							
							// Re-generate skeletons
							rename(n+"-skeleton");
							run("Convert to Mask");						// mask														
							run("Make Binary");							// make binary
							run("Skeletonize");							// skeletonize
							for (a = 0; a < 2; a++)					// set cycles of iterative skeleton pruning
								{run("Prune skeleton", "threshold="+Prune_skeleton_threshold);run("Skeletonize");}		
							Get_outline_skeletons("show=Masks");								
							saveAs("Tiff", Processed_directory+n+"-skeleton.tif"); 		
							close();//
											
							//open in this order					
							open(Processed_directory+n+"-outline.tif");		run("Find Edges");		// Get outline
							
							open(Processed_directory+n+"-nuclei_ROIs.tif"); 		
							run("To ROI Manager"); 
							roiManager("Show All without labels"); 
							nuclei_ROIs = newArray;
							
							for (i=0; i<roiManager("count"); ++i){nuclei_ROIs[i]=i;}
							selectWindow(""+n+"-nuclei_ROIs.tif");
							run("Select All");
							run("Clear", "slice");
							roiManager("Select", nuclei_ROIs);
							roiManager("Fill");
							roiManager("Select", nuclei_ROIs);
							roiManager("Draw");
							run("Invert");
							run("8-bit");
							saveAs("Tiff", Processed_directory+n+"-nuclei.tif");
							run("Find Edges");		// Get outline
							Clear_ROI();					
							
							open(Processed_directory+n+"-kinetoplast_ROIs.tif"); 	
							run("To ROI Manager"); 
							roiManager("Show All without labels"); 
							kinetoplast_ROIs = newArray;
							for (i=0; i<roiManager("count"); ++i){kinetoplast_ROIs[i]=i;}
							selectWindow(""+n+"-kinetoplast_ROIs.tif");
							run("Select All");
							run("Clear", "slice");
							roiManager("Select", kinetoplast_ROIs);
							roiManager("Fill");
							roiManager("Select", kinetoplast_ROIs);
							roiManager("Draw");
							run("Invert");
							run("8-bit");
							saveAs("Tiff", Processed_directory+n+"-kinetoplasts.tif");
							run("Find Edges");		// Get outline
							Clear_ROI();
							
							open(Processed_directory+n+"-skeleton.tif");							// Skeleton already an outline
		
							
							// if window skeleton size is not the same as outlines (for some reason this happens occassionally) resize so that all windows same size.		
							selectWindow(""+n+"-outline.tif");	
							outline_width=getWidth;
							outline_height=getHeight;
							selectWindow(""+n+"-skeleton.tif");	
							skeleton_width=getWidth;
							if(skeleton_width!=outline_width)
								{
								run("Size...", "width="+outline_width+" height="+outline_height+" average interpolation=Bilinear");
								}
							
							open(directory+n+"bf.tif"); run("8-bit");								// Produce a minimally processed brightfield, 8 bit
							
							Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);				// Unsharp
							run("Divide...", "value=4");										// Make dark
							
							run("Merge Channels...", "c3="+n+"-outline.tif c2="+n+"-nuclei.tif c1="+n+"-kinetoplasts.tif c7="+n+"-skeleton.tif c4="+n+"bf.tif create");
							run("Stack to RGB");
							saveAs("Tiff", Processed_directory+n+"-composite.tif"); 	
							close();
							//run("Save", "save="+Processed_directory+n+"-pipe"+pipe+".tif");			// take diagnostic snapshot
							print("Composite for set "+n+" made");
							
							}
						}
					// If no nuclear information, still want a composite available
					else
						{
						open(Processed_directory+n+"-outline.tif"); run("Find Edges");				// Get outline
						open(Processed_directory+n+"-skeleton.tif");
						
						// if window skeleton size is not the same as outlines (for some reason this happens occassionally) resize so that all windows same size.		
						selectWindow(""+n+"-outline.tif");	
						outline_width=getWidth;
						outline_height=getHeight;
						selectWindow(""+n+"-skeleton.tif");	
						skeleton_width=getWidth;
						if(skeleton_width!=outline_width)
							{
							run("Size...", "width="+outline_width+" height="+outline_height+" average interpolation=Bilinear");
							}						
						
						open(directory+n+"bf.tif"); run("8-bit");									// Produce a minimally processed brightfield, 8 bit
							
						Run_unsharp(Run_unsharp_enable, Minimum_skeleton_area);					// Unsharp
						run("Divide...", "value=4");											// Make dark
						
						run("Merge Channels...", "c3="+n+"-outline.tif c7="+n+"-skeleton.tif c4="+n+"bf.tif create");
						run("Stack to RGB");
						saveAs("Tiff", Processed_directory+n+"-composite.tif"); 	
						close();
						//run("Save", "save="+Processed_directory+n+"-pipe"+pipe+".tif");				// take diagnostic snapshot
						print("Skeleton-only composite for set "+n+" made");
						Close_open_images();		
						}
					}
				}
			}
		Close_open_images();
		}
	}
Save_log();
	
if(Start_post_manual==1 || Manually_curate_ROI==1)
	{
	print("wwwwwwwwww PREPARE CELL STACKS USING MANUALLY CORRECTED IMAGES wwwwwwwwww\n");				//
	list = getFileList(directory); Array.sort(list);								// Get all the files in the directory
		for (n=Starting_image; n<(10+Starting_image+list.length); n++) 		// Image sets start at 1, SS+ now allows for starting at different number and allows for 10 missing images before thinks its reached the total
		{																
		print("Looking for "+n+"-outline.tif");							// Diagnostic
		if(File.exists(Processed_directory+n+"-outline.tif") && File.exists(Processed_directory+n+"-composite.tif"))
			{				
			columns = 1;
			open(Processed_directory+n+"-outline.tif");	
			rename("outline");
			

//###### GET ORIGINAL FILES FOR EACH SET ###########
			
			for (i=0; i<Image_types.length; i++)							// open all raw image types in set n
				{
				if(File.exists(directory+n+""+Image_types[i]+".tif"))	
					{open(directory+n+""+Image_types[i]+".tif");	rename(""+Image_types[i]+"");	columns++;}
				}
//###### GET PROCESSED IMAGE PRODUCTS ##########			

			if(File.exists(Processed_directory+n+"-brightfield.tif"))		{open(Processed_directory+n+"-brightfield.tif");		rename("brightfield");	columns++;}
			if(File.exists(Processed_directory+n+"-skeleton.tif"))		{open(Processed_directory+n+"-skeleton.tif");		rename("skeleton");	columns++;}
			if(File.exists(Processed_directory+n+"-nuclei.tif"))			{open(Processed_directory+n+"-nuclei.tif");			rename("nuclei");		columns++;}
			if(File.exists(Processed_directory+n+"-kinetoplasts.tif"))	{open(Processed_directory+n+"-kinetoplasts.tif");	rename("kinetoplasts");	columns++;}
			if(File.exists(Processed_directory+n+"-composite.tif"))		{open(Processed_directory+n+"-composite.tif");		rename("composite");	columns++;}
			else{
				if(isOpen("h"))
					{
					selectWindow("h");
					}
				}
			run("Images to Stack", "name=Stack use");					// images to stack, name from n
			run("Reverse");											// Just so composite is displayed as thumbnail, disable if outline preferred
			saveAs("Tiff", Processed_directory+n+"-stackROI.tif");
			close();
			}
		}
	}
// SS+ I've seperated manual curation and cell extraction, so should be able to do all curation in one go.	
Save_log();

//###### EXTRACT CELLS ###########################
//################################################	

if(Extract_cell_stacks==1)
	{
	print("wwwwwwwwww EXTRACT CELL STACKS wwwwwwwwww\n");
	
	list = getFileList(directory); Array.sort(list);								// Get all the files in the directory
	for (n=Starting_image; n<(10+Starting_image+list.length); n++) 			// Image sets start at 1, SS+ now allows for starting at different number	
		{
		print("Looking for "+n+"-composite.tif");							// Diagnostic
		if(File.exists(Processed_directory+n+"-composite.tif") && File.exists(Processed_directory+n+"-stackROI.tif"))
			{
			if(File.exists(Processed_directory+n+"skip.txt"))
				{
				print("Skipping image "+n+"; no trypanosomes were found on this run");
				}
			else	{
				open(Processed_directory+n+"-composite.tif");				// reload composite
				open(Processed_directory+n+"-stackROI.tif");				// open stack and recover ROIs from overlay
				open(Processed_directory+n+"-ROIs.tif");
				run("To ROI Manager");
				selectWindow(n+"-ROIs.tif");
				close();
							
				for (i=0; i<roiManager("count"); ++i) 							// for each outline detected, 
					{													// and added to the ROI manager previously (numbered 1..N)
					
//###### PROCESS STACK ###########################
					
					selectWindow(n+"-stackROI.tif");							// select stack
					run("Duplicate...", "duplicate");							// duplicate all layers of the stack
					roiManager("Select", i);									// select chosen ROI
					run("Enlarge...", "pixel enlarge=5");						// take slightly more than the bounding box, by 5px
					setBackgroundColor(0, 0, 0);								// outside is black
					run("Clear Outside", "stack");								// Clear out side of selection, remove neighbouring cell problems
					run("Crop");											// crop out
					width = getWidth; height = getHeight;						// get dimensions
					run("Canvas Size...", "width="+(width+30)+" height="+(height+30)+" position=Center zero"); // Resize canvas so cell has 15px boarder
					saveAs("Tiff", Cells_directory+n+"Cell"+(i+1)+"-stack.tif");		// save as (n)Cell(N)-stack.tif
					close();												// close

//###### PROCESS COMPOSITE ######################					
					
					selectWindow(""+n+"-composite.tif");							// select the composites window
					roiManager("Measure");
					Rectangle_1=getResult("BX",i);								// Get X,Y pair information	 //SS+ if overlay elements, columns needed are X and Y, otherwise, BX and BYresults changed from BX and BY to X and Y, I dont know what the 'B' is all about
					Rectangle_2=getResult("BY",i);								// Get X,Y pair information
					Rectangle_3=getResult("Width",i);								// Get X,Y pair information
					Rectangle_4=getResult("Height",i);							// Get X,Y pair information
					setColor(200,0,200);										// Set colour of bounding rectangle, purplish
					drawRect(Rectangle_1, Rectangle_2, Rectangle_3, Rectangle_4); 	// Draw rectangle, defined by two XY pairs, 1,2 / 3,4
					setColor(255,255,255); 										// Set colour of font, white
					setFont("SansSerif",24,"bold");								// Set font properties
					setJustification("center");									// Set font properties
					drawString(i+1,(Rectangle_1+(0.5*Rectangle_3)),(Rectangle_2+(0.5*Rectangle_4))); 		// draw text in middle of rectangle
					}
				selectWindow(""+n+"-composite.tif");								// select composite
				saveAs("Tiff", Processed_directory+n+"-composite.tif"); 				// save annotated composite over original
				Clear_ROI(); Close_open_images();								// tidy up
				}
			}
		else {print("Failed to find "+n+"-outline.tif or "+n+"-composite.tif");}				// Stack fails to contain outline?
		}
	}

//###### ANALYSE EXTRACTED CELLS #################
//################################################

no_repeats = "";

if(Analyse_extracted_cells==1)
	{
	print("wwwwwwwwww ANALYSE EXTRACTED CELLS wwwwwwwwww\n");			
	
	// As default, no manual curation
	outline_curation = 0;
	nuclear_curation = 0;
	
	// If any manual curation has occured (even in previous runs), will read in here.
	if (File.exists(Processed_directory+"manual_curation.txt"))
		{
		curation_settings = File.openAsString(Processed_directory+"manual_curation.txt");
		curation_settings_array = split(curation_settings, "\n");
		outline_curation = parseInt(curation_settings_array[0]);
		nuclear_curation = parseInt(curation_settings_array[1]);
		}
	
	list = getFileList(Cells_directory); Array.sort(list);			// Get all the files in the directory
	for(i=0; i<(list.length-1); i++)							//see if shortening list length stops pipeline error quitting
		{
		// reset variables
		
		// Outline
		Circularity = 0;								// measure of circularity of outline - used to distinguish dead cells
		Solidity = 0;									// measure of tortuosity of outline perimeter - used to distinguish dead cells
		
		// Nuclear structures
		Number_of_nuclei = 0;							// records the number of nuclei detected in the cell
		Number_of_kinetoplasts = 0;					// records the number of kinetopla.sts detected in the cell	
		Kinetoplast_centroids_X = newArray;				// centre point of kinetoplasts, X coordinates
		Kinetoplast_centroids_X[0] = 0;
		Nuclei_centroids_X = newArray;					// centre point of nuclei, X coordinates
		Nuclei_centroids_X[0] = 0;
		Kinetoplast_centroids_Y = newArray;				// centre point of kinetoplasts, Y coordinates
		Kinetoplast_centroids_Y[0] = 0;
		Nuclei_centroids_Y = newArray;					// centre point of nuclei, Y coordinates
		Nuclei_centroids_Y[0] = 0;
		Kinetoplast_areas = newArray;					// areas of kinetoplasts,
		Nuclei_areas = newArray;						// areas of nuclei,
		
		Nuclei_minimum_distance = 0;
		Nuclei_minimum = 0; 						//the coordinate set x  (COORDX[x] and COORDY[x]) where the pythagorian distance between the nucleus centroid and skeleton is smallest
		Kinetoplast_minimum_distance = 0;
		Kinetoplast_minimum = 0;						//the coordinate set x  (COORDX[x] and COORDY[x]) where the pythagorian distance between the nucleus centroid and skeleton is smallest
		Kinetoplast_nuclei_distance = 0;
		
		//Skeleton
		Number_of_skeletons = 0;						// number of skeletons, if not 1, very worrying
		//Skeleton_length = 0;							// length of skeleton produced by skeletonising outline
		Number_of_triple_points = 0;					// number of triple points in the skeletonised outline- like junctions, none probably best
		Skeleton_branchedness = 0;					// measure of branchedness, each triple point ++
		Number_of_end_points = 0;						// should be 2, as in on a line
		Skeleton_quality = 0;							// 0 - do not use, 2 - cautiously use, 3 - ok for use
		
		Skeleton_length = 0;							// Length of skeleton measured as the sum of distances between pixel centerpoints
		Skeleton_area = 0;							// Number of pixels in skeleton NB not the same as length, non pythagorean
		Start_x = 0; Start_y = 0;						// Start coordinates for skeleton traversal - equal chance of being anterior or posterior

		//Ridge
		Cell_width = 0;								// average cell width from ridge detection
		Number_of_junctions = 0;						// number of junctions in centerline ridge in ridge detection - unjunctioned probably best
		ridge_branchedness = 0;						// measure of branchedness segment in summary ++
		Cumulative_ridge_length = 0;							 

		//Positioning nuclear structures on skeleton
		Rebuilt_skeleton = 0;
		Skeleton_grey = 0;
		Nuc_min_distance_to_skeleton_end = 0;
		Nuc_to_end1 = 0;							//cannot be sure which way round the cell is. The assumption we make here is that the end closest to the nucleus is the posterior (as free flagellum makes it unlikely that the anterior will be closest);
		Nuc_to_end2 = 0;
		Kin_min_distance_to_skeleton_end = 0;
		Kin_to_end1 = 0;
		Kin_to_end2 = 0;
		KN_along_skeleton = 0;
		
		
//###### OPEN STACK #############################
		
		if( list[i] != "Analysed cells/")
			{
			if(File.exists(Cells_directory+list[i]) && list[i] != "Analysed cells/")	// IF... allows for parallel sorting, removes necessity to continually scan directory. Had a problem where it was trying to open the Analyse cells directory as an image. solved now.
				{
				print("\nwwwwww Opening: "+list[i]+" wwwwww");			// diagnostic
				open(Cells_directory+list[i]);								// open cell stack
				File.delete(Cells_directory+list[i]);							// delete associated file from original directory (take out of processing pool)
				saveAs("Tiff", Analysed_cells_directory+list[i]);				// save file to analysed cells directory
				list = Array.slice(list, 0);									// remove from list of files to look for
				run("Stack to Images");									// Stack to images		

//###### ANALYSE CELLS ###########################
// Tests for whether cell is a sensible size and shape
//###############################################	

				// Tests for validity: removes things if they are excessively invaginated / look like blackberries
				if(isOpen("outline"))													
					{
					selectWindow("outline");											
					run("Make Binary");													
					run("Convert to Mask");												
					run("Set Scale...", "distance=0 known=0 pixel=1 unit=pixel");			// not square inches
					run("Set Measurements...", "area shape");							// NB here we include shape- one result of which is solidity
					
					//relaxed parameters if outlines have been manually curated
					if (outline_curation==1)
						{
						print("curation detected, finding outlines");
						selectWindow("outline");
						run("Analyze Particles...", "size=0-infinity circularity=0-1 show=Masks display exclude clear add"); //I am happy to lift restrictions here, as should have already been curated
						}						
					else if (outline_curation==0)
						{run("Analyze Particles...", "size="+Min_tryp_area+"-"+Max_tryp_area+" pixel circularity="+Circularity_range+" display exclude clear add");}
					if(1<nResults)												//if there is more than one ROI, cannot process circularity or solidity properly, so need to close any gaps!
						{
						Clear_non_image_windows();
						run("Remove Outliers...", "radius=2 threshold=50 which=Dark");
						print("multiple ROIs detected. Removing fragments");
						run("Analyze Particles...", "size=0-infinity circularity=0-1 show=Masks display exclude clear add");  //this problem is only likely to occur if outlines manually amended, so can lift restrictions here.
						}						
					if(true==nResults)												// If there is a result- there really ought to be as this is basically redefining outline
						{
						Solidity=getResult("Solidity",0);								// Get value for solidity from results table
						Circularity=getResult("Circ.",0);
						print("\nSolidity: "+Solidity+", Circularity: "+Circularity+"\n");			// Write to log
						if (Solidity < Solidity_lower_cell_limit && Circularity > Circularity_upper_cell_limit)		// This is probably ok, actually rather hard to get something below 0.5		
							{
							//print(list[i]+" Fails to pass solidity test. Deleting\n");			// write failure to log			
							print(list[i]+" Fails to pass solidity test.\n");
							//Close_open_images();								// Close images
							File.append(list[i]+",validity,failed solidity,\n", Analysed_cells_directory + "Unusual_cells.txt"); 
							//File.delete(Analysed_cells_directory+list[i]);					// Delete cell stack
							}
						Clear_ROI();												
						}
					}
				
				// Tests for validity: if nuclear structures have been processed, is there a nucleus?
				if(isOpen("nuclei"))													
					{
					Clear_ROI();					
					print("\nStack assembled from set with nuclear structure processing\nChecking for the presence of a nucleus");
					selectWindow("nuclei");											// get nuclei
					if (nuclear_curation==1)
						{
						run("Make Binary");
						Get_curated_structures("");
						print("obtaining nuclei from curated ROIs");
						}									// if nuclear structures manually curated, can relax parameters
					else if (0==nuclear_curation)
						{
						run("Make Binary");											// as stack is RGB initially
						Get_nuclear_structures("");									// using same parameters as initial pass
						print("obtaining nuclei from ROIs");
						}
					Number_of_nuclei = roiManager("count");							
					
					// If there is no nucleus- delete nuclei window
					// SS+ I have removed this so that we still get length measurements for cells that we have no nuclei for
					if(0==roiManager("count"))										// If no nucleus
						{
						print(list[i]+" No nucleus, proceed with caution.");
						File.append(list[i]+",nuclei,no nuclei,\n", Analysed_cells_directory + "Unusual_cells.txt"); 
						selectWindow("nuclei");
						close();
						//print(list[i]+" Fails to qualify as a cell- No nucleus. Deleting");					
						//Close_open_images();										// Close images
						//File.delete(Analysed_cells_directory+list[i]);						// Delete cell stack
						//File.append(list[i]+",nuclei,no nuclei,\n", Analysed_cells_directory + "deleted_cells.txt"); 
						}
						
					// If has at least one nucleus, but less than 4
					else	if (0!=roiManager("count"))														// if number of nuclei not zero
						{
						// If there are 4 or more nuclei, flag as may be an aggregate
						if (3<roiManager("count"))
							{
							print(list[i]+" Too many nuclei, probably aggregate. Proceed with caution.");					
							File.append(list[i]+",nuclei,too many nuclei,"+roiManager("count")+"\n", Analysed_cells_directory + "Unusual_cells.txt"); 
							}
						print(list[i]+" Has at least one nucleus");						// report to log
						for(u=0; u<Number_of_nuclei; u++)							// as its logical, procede with characterising nucleus
							{
							Nuclei_areas[u] = getResult("Area", u); print("Nucleus "+u+" area (pixels): "+getResult("Area", u)+", area (µm): "+Convert_to_microns(getResult("Area", u)));
							Nuclei_centroids_X[u] = getResult("X", u); Nuclei_centroids_Y[u] = getResult("Y", u);
							print("Nucleus centroid: "+getResult("X", u)+","+getResult("Y", u));
							File.append("NUCLEUS,"+u+", area:"+getResult("Area", u)+","+getResult("X", u)+"pixel co-ords: "+getResult("Y", u) +"\n", Cell_data_directory + list[i] + ".txt");
							}
						Clear_ROI();
						}
					Clear_non_image_windows();
					}
				
				// Might as well characterise kinetoplasts at this point, though I am not calling these essential at this point, 
				// but if there is more than 4 something has probably gone wrong and the image should be discarded
				
				if(isOpen("kinetoplasts"))											
					{
					Clear_ROI();
					print("Processing kinetoplasts");									
					selectWindow("kinetoplasts");									// get kinetoplast
					if (nuclear_curation==1)
						{
						run("Make Binary");
						Get_curated_structures("");
						print("obtaining kinetoplasts from curated ROIs");
						}									// if nuclear structures manually curated, can relax parameters
					else	if (nuclear_curation==0)
						{
						run("Make Binary");											// as stack is RGB initially
						Get_nuclear_structures("");									// using same parameters as initial pass
						print("obtaining kinetoplasts from ROIs");
						}										//
					Number_of_kinetoplasts = roiManager("count");						

					if(0==roiManager("count"))										// If no nucleus
						{
						print(list[i]+" No kinetoplasts detected");						// Not fatal on these settings
						}
					else	if (0!=roiManager("count"))												// if number of nuclei not zero
						{
						// If there are 5 or more kineotoplasts flag as possibly an aggregates
						if (4<roiManager("count"))								
							{
							//print(list[i]+" Too many kinetoplasts, something probably wrong. Deleting");					
							print(list[i]+" Too many kinetoplasts, something probably wrong. Caution");
							File.append(list[i]+",kinetoplasts,too many kinetoplasts,"+roiManager("count")+"\n", Analysed_cells_directory + "Unusual_cells.txt"); 
							}
							
						print(list[i]+" Has at least one kinetoplast");						// report to log
						for(x=0; x<Number_of_kinetoplasts; x++)						// as its logical, procede with characterising nucleus
							{
							Kinetoplast_areas[x] = getResult("Area", x); print("Kinetoplast "+x+" area (pixels): "+getResult("Area", x)+", area (µm): "+Convert_to_microns(getResult("Area", x)));
							Kinetoplast_centroids_X[x] = getResult("X", x); Kinetoplast_centroids_Y[x] = getResult("Y", x);
							print("Kinetoplast centroid: "+getResult("X", x)+","+getResult("Y", x));
							File.append("KINETOPLAST,"+x+",area: "+getResult("Area", x)+", pixel coords: "+getResult("X", x)+","+getResult("Y", x) +"\n", Cell_data_directory + list[i] + ".txt");
							}
						}
					Clear_non_image_windows();
					}

//###### SKELETON ANALYSIS ######################################
// Basic examination of skeleton, produce one if cell stack deficient from brightfield


				if(isOpen("skeleton") && isOpen("brightfield") && isOpen("outline"))		// If there is a skeleton / brightfield / outline 
					{
					print("\nAnalyse skeleton: ");										// Diagnostic
					selectWindow("brightfield"); 	run("8-bit");							// Prepare images
					selectWindow("skeleton"); 		run("8-bit");						// Prepare images			
					run("Duplicate...", " "); 		rename("skeleton_area");				// Create copy and call skeleton_area
					selectWindow("skeleton_area");	run("8-bit");						// Prepare images
					run("Convert to Mask");			run("Make Binary");				// Prepare images
					Get_outline_skeletons("show=Masks");							// See if you obtain a skeleton
					
					if(1==nResults)												// if there skeletons which pass
						{
						Skeleton_area=getResult("Area",0);							// Set skeleton area to result
						print("Skeleton area = "+Skeleton_area);						// Diagnostic
						selectWindow("Results"); run("Close");						// Tidy up
						File.append("SKELETON AREA,"+Skeleton_area+"\n", Cell_data_directory + list[i] + ".txt");
						}
					else if(0==nResults)											// no skeleton found, obviously troubling if true
						{
						selectWindow("skeleton"); 		close();						// discard skeleton
						selectWindow("outline");
						// select outline
						run("Duplicate...", " "); 		rename("skeleton_area_rebuild");			// create duplicate	
						run("8-bit");
						run("Invert LUT");
						run("Invert");
						run("Make Binary");			// prepare image
						run("Skeletonize");											// produce skeleton
						run("Duplicate...", " ");
						rename("skeleton");		// Replace skeleton
						selectWindow("skeleton_area_rebuild");
						run("Convert to Mask");	
						Rebuild_skeletons("show=Masks");						// detect skeleton
						if(true==nResults)
							{
							Skeleton_area=getResult("Area",0);						// Set skeleton area to result
							print("Had to rebuild skeleton from outline- curious, Skeleton area = "+Skeleton_area);	// Diagnostic
							File.append(list[i]+", skeleton analysis,skeleton outside expected range,\n", Analysed_cells_directory + "Unusual_cells.txt"); 
							Rebuilt_skeleton = 1;
							}	
						else {
							print("something is not right here, failed to find skeleton, failed to generate acceptable skeleton from outline");	
							Skeleton_area=0;
							File.append(list[i]+",skeleton analysis,no valid skeleton,\n", Analysed_cells_directory + "Unusual_cells.txt"); 
							}
						selectWindow("skeleton_area_rebuild"); close();
						
						}	
																						
					selectWindow("skeleton_area"); close();
					selectWindow("Mask of skeleton_area"); close();	// tidy up

//###### ANALYSE SKELETON ############################

					selectWindow("skeleton");										
					run("Analyze Skeleton (2D/3D)", "prune=none show"); 				
					
//###### IF THERE ARE RESULTS: #########################	

					
					if(true==nResults)													
						{
						// If a skeleton is found, assess
						Number_of_skeletons = nResults;						print("Results: "+nResults);
						Skeleton_branchedness = getResult("# Branches",0);		print("Branches: "+Skeleton_branchedness);
						Number_of_triple_points = getResult("# Triple points",0);		print("Triple points: "+Number_of_triple_points);
						Skeleton_length = getResult("Maximum Branch Length",0);	print("Maximum Branch Length: "+Skeleton_length);
						Number_of_end_points = getResult("# End-point voxels",0);	print("End points: "+Number_of_end_points);

						//What to do with the various results

						if (Number_of_skeletons>1)									// If there is more than one skeleton present- very dubious, delete.
							{
							print(list[i]+" More than one skeleton detected- worrying. Caution");					
							//Close_open_images();									// Close images
							//File.delete(Analysed_cells_directory+list[i]);					// Delete cell stack
							File.append(list[i]+",skeleton analysis, 1<skeletons detected,\n", Analysed_cells_directory + "Unusual_cells.txt"); 
							Clear_non_image_windows();							// tidy up
							Start_x = 0; Start_y = 0;								// set these variable to disable skeleton traversal
							}
						else if (Number_of_triple_points>0 && Number_of_triple_points<4)	// If there is a skeleton present but it has more branches than I'd like
							{
								
							// attempt re-run using brightfield
								
							print("\nTrying to redraw skeleton from outline"); 			// see below
							Clear_non_image_windows();							// close previous analysis
							selectWindow("skeleton"); 		close();
							selectWindow("brightfield");								// start over by re-processing brightfield	
							run("Duplicate...", " ");		rename("skeleton");			
							run("Multiply...", "z=5");								
							run("Subtract Background...", "rolling=3 light create sliding disable");
							run("Invert");												
							run("Multiply...", "value=20.000");															
							run("Make Binary");		
							run("Skeletonize");											
							run("Prune skeleton", "threshold=10.0");					
							if(isOpen("skeleton-pruned"))								
								{
								selectWindow("skeleton"); close();						
								selectWindow("skeleton-pruned");						
								rename("skeleton");		
								}
							run("Skeletonize");										// gets rid of those little nobbles that pruning sometimes produces
							run("Analyze Skeleton (2D/3D)", "prune=none show");			
							run("Make Binary");
							run("Invert LUT");
							//Don't ask. There seems to have been a rogue skeleton open, so just applying a placeholder here fixed the problem!
							rename("patch");
							selectWindow("skeleton"); close();
							selectWindow("patch");
							rename("skeleton");
							

							if(true == nResults)
								{
								Number_of_skeletons = nResults;						print("Results: "+nResults);
								Skeleton_branchedness = getResult("# Branches",0);		print("Branches: "+Skeleton_branchedness);
								Number_of_triple_points = getResult("# Triple points",0);		print("Triple points: "+Number_of_triple_points);
								Skeleton_length = getResult("Maximum Branch Length",0);	print("Maximum Branch Length: "+Skeleton_length);
								Number_of_end_points = getResult("# End-point voxels",0);	print("End points: "+Number_of_end_points);
							
								// remains more branchy than I'd like
								if(Number_of_triple_points>0)
									{
									print("Hrmmm not fixed"); Skeleton_quality = 0;
									File.append("SKELETON,"+Skeleton_quality+","+Convert_to_microns(Skeleton_length)+"µm,"+Number_of_triple_points+","+Number_of_end_points +"\n", Cell_data_directory + list[i] + ".txt");
									Clear_non_image_windows();						
									}
								else if (Number_of_triple_points==0)
								// If the skeleton has been fixed
									{
									print("Possibly better skeleton obtained"); Skeleton_quality = 2;
									File.append("SKELETON,"+Skeleton_quality+","+Convert_to_microns(Skeleton_length)+"µm,"+Number_of_triple_points+","+Number_of_end_points +"\n", Cell_data_directory + list[i] + ".txt");
									selectWindow("Results"); run("Close");
									selectWindow("Branch information"); 
									IJ.renameResults("Branch information", "Results");
									if(true == nResults)
										{
										print("\nEnd point for skeleton traversal "+getResult("V1 x",0)+","+getResult("V1 y",0) );
										Start_x = getResult("V1 x",0); Start_y = getResult("V1 y",0);
										File.append("SKELETON END POINTS,"+getResult("V1 x",0)+","+getResult("V1 y",0)+","+getResult("V2 x",0)+","+getResult("V2 y",0)+"\n", Cell_data_directory + list[i] + ".txt");
										selectWindow("skeleton");
										run("Duplicate...", " "); 		rename("skeleton_area");				// Create copy and call skeleton_area
										selectWindow("skeleton_area");	run("8-bit");						// Prepare images
										run("Convert to Mask");			run("Make Binary");				// Prepare images
										Rebuild_skeletons("show=Masks");	
										if (1==nResults)
											{
											Skeleton_area=getResult("Area",0);
											print("Area of 'improved' skeleton (for traversal use) = "+Skeleton_area);
											selectWindow("Results"); run("Close");
											File.append("IMPROVED SKELETON AREA,"+Skeleton_area+"\n", Cell_data_directory + list[i] + ".txt");
											}
										selectWindow("skeleton_area"); close();
										selectWindow("Tagged skeleton"); close();
										}
									else if (false == nResults)
										{
										print("Something has gone wrong with skeleton improvement, multiple results detected ");
										File.append(list[i]+",skeleton improvement, multiple results detected,\n", Analysed_cells_directory + "Unusual_cells.txt");
										}
									Clear_non_image_windows();
									}
								}
							}
						
						// If the skeleton is straight off ok, collect the results				
						else if (Skeleton_branchedness == 1 && Number_of_triple_points == 0 && Number_of_end_points==2)
							{
							print("This looks like a decent skeleton"); Skeleton_quality = 3;
							File.append("SKELETON,"+Convert_to_microns(Skeleton_length)+"µm,"+Skeleton_quality+","+Number_of_triple_points+","+Number_of_end_points +"\n", Cell_data_directory + list[i] + ".txt");
							selectWindow("Results"); run("Close");
							selectWindow("Branch information"); 
							IJ.renameResults("Branch information", "Results");
							if(true == nResults)
								{
								print("\nEnd point for skeleton traversal "+getResult("V1 x",0)+","+getResult("V1 y",0) );
								Start_x = getResult("V1 x",0); Start_y = getResult("V1 y",0);
								File.append("SKELETON END POINTS,"+getResult("V1 x",0)+","+getResult("V1 y",0)+","+getResult("V2 x",0)+","+getResult("V2 y",0)+"\n", Cell_data_directory + list[i] + ".txt");
								}
							Clear_non_image_windows();
							}
						else if (Number_of_triple_points > 3)						// If the skeleton is ghastly complex
							{
							print(list[i]+" This is very branchy, and clearly worrying. Caution");					
							//Close_open_images();								// Close images
							//File.delete(Analysed_cells_directory+list[i]);				// Delete cell stack
							File.append(list[i]+",skeleton analysis,branchy skeleton,\n", Analysed_cells_directory + "Unusual_cells.txt"); 
							Clear_non_image_windows();					
							Start_x = 0; Start_y = 0;							// set these variable to disable skeleton traversal
							}
						}
						

//###### IF NO SKELETON ############################
// SS+ Comment out to retain cells with KN distance detectable.
					//else 
						//{
						//print("No skeleton?");									// If no skeleton of any kind is found, delete
						//print(list[i]+" - On this setting I am being harsh and erasing things without skeletons. Deleting");			
						//Close_open_images();									// Close images
						//File.delete(Analysed_cells_directory+list[i]);					// Delete cell stack
						//File.append(list[i]+",skeleton analysis,no skeleton,\n", Analysed_cells_directory + "deleted_cells.txt"); 
						//Start_x = 0; Start_y = 0;
						//}
					}
					
//###### IF NO SOURCES ############################
					
				else	
					{print("No skeleton, outline, or brightfield channels?");Start_x = 0; Start_y = 0;}			

//###### RIDGE LENGTH ANALYSIS ####################	
					
				if(isOpen("brightfield"))											
					{
					Clear_non_image_windows();										
					print("\nRidge detection method for length:");					
					selectWindow("brightfield");									
					run("Duplicate...", " ");							
					rename("ridge");		
					run("8-bit");
					run("Subtract Background...", "rolling=2 light create sliding");
					run("Invert");													
					run("Multiply...", "value=10.000");								
					run("Invert");												// sigma 2.5 default
					run("Ridge Detection", "line_width=2.5 high_contrast=230 low_contrast=50 correct_position estimate_width extend_line show_junction_points displayresults add_to_manager method_for_overlap_resolution=SLOPE sigma=2.50 lower_threshold=0.4 upper_threshold=5.44 minimum_line_length=30 maximum=0");
					selectWindow("Results"); run("Close");								
					selectWindow("Summary");										
					IJ.renameResults("Summary", "Results");								
					if(0<nResults) 													
						{
						r =  nResults;												
						Cumulative_ridge_length = 0;								
						for (q=0;q<r;q++)											
							{
							print("ridge length path "+q+":"+getResult("Length",q));			
							Cumulative_ridge_length = Cumulative_ridge_length + getResult("Length",q);
							}
						print("Cumulative ridge length: "+Cumulative_ridge_length);	//
						File.append("RIDGE,"+Convert_to_microns(Cumulative_ridge_length)+"µm,"+getResult("Length",0)+","+r+"\n", Cell_data_directory + list[i] + ".txt");
						}
					else
						{print("No ridge results: "+nResults);}						//
					Clear_ROI();
					}

//###### SKELETON TRAVERSAL ##########################	
					
				if (0!=Cumulative_ridge_length && 0!=Skeleton_length && 0!=Start_x && 0!=Start_y)	// Make a judgement on whether the cell succeeds at both length methods
					{
					if(isOpen("skeleton"))											// Ought to be, fail safe
						{
						print("Attempting skeleton traversal");							// Diagnostic
						
						// Preparation
						selectWindow("skeleton");									// Select window
						run("Duplicate...", " ");		rename("traversal");				
						run("8-bit");												// Prepare image
						print("Beginning");											// Diagnostic
						X_OFFSET = newArray(  0,  1,  1,  1,  0, -1, -1, -1 ); 		// These arrays describe the eight pixels around the one being examined
						Y_OFFSET = newArray( -1, -1,  0,  1,  1,  1,  0, -1 );		// being examined, they are always 1 px greater or less, or equal if on same axis
						
						/*			#########################
									#       #       #       #
									# -1, 1 #  0, 1 #  1, 1 #
									#       #       #       #
									#########################
									#       #       #       #
									# -1, 0 # FOCUS #  1, 0 #
									#       #       #       #
									#########################
									#       #       #       #
									# -1,-1 #  0,-1 #  1,-1 #
									#       #       #       #
									#########################		*/
						
						COORDX = newArray;										// Array to store the X portion of the XY pairs generated during traversal
						COORDY = newArray;										// Array to store the Y elements of the traversal
						Coordinate_string = "COORDINATE PAIRS (pixels),";					// Line header for cell txt file
						
						// Traversal
						for (j=0; j<(Skeleton_area); j++)  							// Just to limit it in case something weird, like a loop
							{ 
							for (z=0; z<8; z++) 									// Set up to check the 8 surrounding squares
								{ 
								neighbor = getPixel(Start_x+X_OFFSET[z], Start_y+Y_OFFSET[z]); 		// check a surrounding square
								if (neighbor == 255) 											// if its the next point (untouched)
									{
									print((j+1)+"/"+Skeleton_area+": "+Start_x + "," + Start_y);			// Diagnostic
									Coordinate_string = Coordinate_string+Start_x+","+Start_y+",";		// Append to string to write to file
									COORDX[j]=Start_x;				COORDY[j]=Start_y;		// Add point to arrays
									setPixel(Start_x, Start_y, 100);								// Mark pixel, to prevent revisit
									Start_x=Start_x+X_OFFSET[z];	Start_y=Start_y+Y_OFFSET[z];			// Next time around start at this position
									z=8;														// break (quit the loop) 									
									} 
								} 
							}
						selectWindow("traversal"); close();
						
						// Post processing
						File.append(Coordinate_string+"\n", Cell_data_directory + list[i] + ".txt");		// Write coordinate pairs to file
						if (0!=Number_of_nuclei) 			// if nuclei present
							{	
							for (p=0;p<Number_of_nuclei;p++)														
								{																					
								Nuclei_close_approach_array=newArray;								// Reset variables	
								
								for (q=0;q<COORDX.length;q++)														
									{Nuclei_close_approach_array[q]=Get_pythagorean_distance(COORDX[q], Nuclei_centroids_X[p], COORDY[q], Nuclei_centroids_Y[p]);}
								
								Nuclei_minimum_distance = 1000;									// Reset variables
								//Nuclei_minimum_distance represents the distance between the nucleus centroid and the point on the skeleton at which the nucleus is closest. In the case of multiple nuclei, it will find the nucleus closest to the skeleton.	
								Nuclei_minimum=0;																
								//Nuclei_minimum is the number of pixels (coordinate pairs) between one end of the skeleton and the coordinates of the point at which the nucleus is closest.
								
								for(x=0;x<Nuclei_close_approach_array.length;x++)									
									{																			
									if (Nuclei_minimum_distance>Nuclei_close_approach_array[x])						
										{Nuclei_minimum_distance=Nuclei_close_approach_array[x];Nuclei_minimum=x;}	
									}																				
								print("Nucleus "+p+" is "+Convert_to_microns(Nuclei_minimum_distance)+"µm from the skeleton, "+Nuclei_minimum+"pixels to end.");
								File.append("NUCLEI "+p+" SKELETON POSITION (pixels),"+Nuclei_minimum+", SKELETON POSITION (µm), "+Convert_to_microns(Nuclei_minimum)+" \n", Cell_data_directory + list[i] + ".txt");
								}
							}
						else if (0==Number_of_nuclei)
							{Nuclei_minimum_distance=0; Nuclei_minimum=0;}
						
						if (0!=Number_of_kinetoplasts)
							{
							for (p=0;p<Number_of_kinetoplasts;p++)													
								{																					
								Kinetoplast_close_approach_array=newArray;											
								
								for (q=0;q<COORDX.length;q++)														
									{Kinetoplast_close_approach_array[q]=Get_pythagorean_distance(COORDX[q], Kinetoplast_centroids_X[p], COORDY[q], Kinetoplast_centroids_Y[p]);}
								
								Kinetoplast_minimum_distance = 1000;	
								//Kinetoplast_minimum_distance represents the distance between the kinetoplast centroid and the point on the skeleton at which the kinetoplast is closest. In the case of multiple kinetoplasts, it will find the kinetoplast closest to the skeleton.								
								Kinetoplast_minimum=0;		
								//Kinetoplast_minimum is the number of pixels (coordinate pairs) between one end of the skeleton and the coordinates of the point at which the kinetoplast is closest.
								
								for(x=0;x<Kinetoplast_close_approach_array.length;x++)								
									{																				
									if (Kinetoplast_minimum_distance>Kinetoplast_close_approach_array[x])			
										{Kinetoplast_minimum_distance=Kinetoplast_close_approach_array[x];Kinetoplast_minimum=x;}
									}
								print("Kinetoplast "+p+" is "+Convert_to_microns(Kinetoplast_minimum_distance)+" µm from the skeleton, "+Kinetoplast_minimum+"pixels to end."); 
								File.append("KINETOPLAST "+p+" SKELETON POSITION (pixels),"+Kinetoplast_minimum+", SKELETON POSITION (µm), "+Convert_to_microns(Kinetoplast_minimum)+"\n", Cell_data_directory + list[i] + ".txt");
								}
							}
						else if (0==Number_of_kinetoplasts)
							{Kinetoplast_minimum_distance=0; Kinetoplast_minimum=0;}
						print("Skeleton area  (pixel count) "+Skeleton_area);
						
						// Orient  minimums from closest end of skeleton (most likely posterior)
						//if (((Nuclei_minimum+Kinetoplast_minimum)/2) > Skeleton_area/2)  //this is using skeleton area as a measure of length. Not sure I''m happy with this
						//	{
						//	Nuclei_minimum = Skeleton_area - Nuclei_minimum;
						//	Kinetoplast_minimum = Skeleton_area - Kinetoplast_minimum;
						//	}
						
						// ^ No longer needed, as  minimum length found below			
						
						// Find minimum distance from nucleus to cell skeleton end (output for first nucleus only)
				
						if(0!=Nuclei_minimum)
							{
							Nuc_min_distance_to_skeleton_end=0; //set up 
							Nuc_to_end1 = 0;
							Nuc_to_end2 = 0;
							selectWindow("skeleton");
							//test to first end
							run("Duplicate...", "title=Nuc_to_end1");
							Clear_non_image_windows();
							for (k=0; k<(Nuclei_minimum); k++)
								{
								makePoint(COORDX[k],COORDY[k]);
								roiManager("Add");
								}
							setForegroundColor(0,0,0);
							if(1==Rebuilt_skeleton)  		// for some reason, if I rebuild skeletons from outline, it gives me an inverse image, but inverting the image at the 'rebuild' stage is not effective. Therefore need to include Rebuilt_skeleton  to track when inverse colour is needed for cropping skeleton!
								{setForegroundColor(255,255,255);}
							for(k=0; k<((roiManager("count"))-1); k++)
								{ 
								roiManager("Select", k);
								run("Draw", "slice");
								}
							selectWindow("Nuc_to_end1");
							run("8-bit");
							run("Analyze Skeleton (2D/3D)", "prune=none show"); 
							Nuc_to_end1 = getResult("Maximum Branch Length", 0); 
							print("Nuc distance to end1 = "+Nuc_to_end1+" pixels / "+Convert_to_microns(Nuc_to_end1)+"µm.");
							Nuc_min_distance_to_skeleton_end = Nuc_to_end1;
							selectWindow("Nuc_to_end1");
							close();
							//test to other end
							selectWindow("skeleton");
							run("Duplicate...", "title=Nuc_to_end2");
							Clear_ROI();
							for (k=Nuclei_minimum; k<((COORDX.length)-1); k++)
								{
								makePoint(COORDX[k],COORDY[k]);
								roiManager("Add");
								}
							setForegroundColor(0,0,0);
							if(1==Rebuilt_skeleton)
								{setForegroundColor(255,255,255);}
							for(k=0; k<((roiManager("count"))-1); k++)
								{ 
								roiManager("Select", k);
								run("Draw", "slice");
								}
							selectWindow("Nuc_to_end2");
							run("8-bit");
							run("Analyze Skeleton (2D/3D)", "prune=none show"); 
							Nuc_to_end2 = getResult("Maximum Branch Length", 0); 
							print("Nuc distance to end2 = "+Nuc_to_end2+" pixels / "+Convert_to_microns(Nuc_to_end2)+"µm.");
							if (Nuc_to_end2<Nuc_to_end1)
								{
								Nuc_min_distance_to_skeleton_end = Nuc_to_end2;
								}
							selectWindow("Nuc_to_end2");
							close();	
							Clear_ROI();
							print("Skeleton end to nucleus = "+Nuc_min_distance_to_skeleton_end+" pixels, "+Convert_to_microns(Nuc_min_distance_to_skeleton_end)+"µm");
							}
						// Find minimum distance from kinetoplast to cell skeleton end (output for first kinetoplast only)
						if(0!=Kinetoplast_minimum)
							{
							Kin_min_distance_to_skeleton_end=0; //set up 
							Kin_to_end1 = 0;
							Kin_to_end2 = 0;
							selectWindow("skeleton");
							//test to first end
							run("Duplicate...", "title=Kin_to_end1");
							Clear_ROI();
							for (k=0; k<(Kinetoplast_minimum); k++)
								{
								makePoint(COORDX[k],COORDY[k]);
								roiManager("Add");
								}
							setForegroundColor(0,0,0);
							if(1==Rebuilt_skeleton)
								{setForegroundColor(255,255,255);}
							for(k=0; k<((roiManager("count"))-1); k++)
								{ 
								roiManager("Select", k);
								run("Draw", "slice");
								}
							selectWindow("Kin_to_end1");
							run("8-bit");
							run("Analyze Skeleton (2D/3D)", "prune=none show"); 
							Kin_to_end1 = getResult("Maximum Branch Length", 0); 
							print("Kin distance to end1 = "+Kin_to_end1+"pixels / "+Convert_to_microns(Kin_to_end1)+"µm.");
							Kin_min_distance_to_skeleton_end = Kin_to_end1;
							selectWindow("Kin_to_end1");
							close();
							//test to other end
							selectWindow("skeleton");
							run("Duplicate...", "title=Kin_to_end2");
							Clear_ROI();
							for (k=Kinetoplast_minimum; k<((COORDX.length)-1); k++)
								{
								makePoint(COORDX[k],COORDY[k]);
								roiManager("Add");
								}
							setForegroundColor(0,0,0);
							if(1==Rebuilt_skeleton)
								{setForegroundColor(255,255,255);}
							for(k=0; k<((roiManager("count"))-1); k++)
								{ 
								roiManager("Select", k);
								run("Draw", "slice");
								}
							selectWindow("Kin_to_end2");
							run("8-bit");
							run("Analyze Skeleton (2D/3D)", "prune=none show"); 
							Kin_to_end2 = getResult("Maximum Branch Length", 0); 
							print("Kin distance to end2 = "+Kin_to_end2+"pixels / "+Convert_to_microns(Kin_to_end2)+"µm.");
							if (Kin_to_end2<Kin_to_end1)
								{
								Kin_min_distance_to_skeleton_end = Kin_to_end2;
								}
							selectWindow("Kin_to_end2");
							close();	
							Clear_ROI();
							print("Skeleton end to kinetoplast = "+Kin_min_distance_to_skeleton_end+" pixels, "+Convert_to_microns(Kin_min_distance_to_skeleton_end)+" µm");
															
							if(0!=Kinetoplast_minimum && 0!=Nuclei_minimum)
								{				
								//Get KN_along_skeleton
								// The distance between N and K will always be the same, no matter which end you measure from. However, must measure from the same end for both!
								//call abs(n) to get the absolute value (ignore +/-)
								KN_along_skeleton=abs(Kin_to_end1-Nuc_to_end1);
								print("Distance between the Nucleus and Kinetoplast along the skeleton is: "+KN_along_skeleton+ "pixels, "+Convert_to_microns(KN_along_skeleton)+"µm.");
								}
							//if(Nuc_to_end1==Nuc_to_end2)
							//	{
							//	print("Something has gone wrong during skeleton traversal. Deleting minimum distance measurements.");
							//	File.append(list[i]+",skeleton traversal, minimum distances error,\n", Analysed_cells_directory + "Unusual_cells.txt");
							//	Nuc_min_distance_to_skeleton_end = 0;
							//	Kin_min_distance_to_skeleton_end = 0;
							//	KN_along_skeleton = 0;
							
							}
						}	
					}												
				Save_log();
				}
					
			// Everything which successfully passes checks for branches, and consistent length is probably a nice cell
			if (0!=Skeleton_length && 0!=Start_x && 0!=Start_y)  				// SS+: removed requirement for ridge found for cell to be 'nice'
				{niceness=1;} 											// So we declare this nice
			else{niceness=0;} 						

//###### SORTING ANALYSED CELLS ######################

			// Prepare channels
			if(isOpen("brightfield"))		{selectWindow("brightfield");		run("Blue");	}	// Make brightfield outline shades of blue
			if(isOpen("skeleton"))		{selectWindow("skeleton");		run("Yellow");	}	// Make skeleton a yellow line, NB the traversed end is indicated
			if(isOpen("nuclei"))			{selectWindow("nuclei");		run("Green");	}	// Make declared nuclei green
			if(isOpen("kinetoplasts"))	{selectWindow("kinetoplasts");	run("Red");	}	// Make declared kinetoplasts red

			//// If all of the above are open, produce a montage image, (here, we only bother with nice cells, but this can be disabled)
			//if(isOpen("brightfield") && isOpen("skeleton") && isOpen("nuclei") && isOpen("kinetoplasts") && niceness==1 )
			
			if(isOpen("nuclei"))
				{
				if(isOpen("brightfield") && isOpen("skeleton") && isOpen("kinetoplasts"))
					{
					print("Merging brightfield, nuclei, skeleton and kinetoplasts...");
					run("Merge Channels...", "c3=brightfield c2=nuclei c1=kinetoplasts c7=skeleton create keep"); 
					run("Stack to RGB");
					}
				}
			else
				{
				if(isOpen("brightfield") && isOpen("skeleton"))
					{
					print("Merging brightfield and skeleton...");
					run("Merge Channels...", "c3=brightfield c7=skeleton create keep"); 
					run("Stack to RGB");
					}
				}
			// Sort singlets
			if (1==Number_of_nuclei && 1==Number_of_kinetoplasts && niceness==1 && Get_non_dividing_singlets==1)
				{
				print("Clean singlet found. Making montage...");
				run("Images to Stack", "name=Stack use");									//
				saveAs("Tiff", Clean_singlets_directory+list[i]);							//
				run("Make Montage...", "columns=10 rows=1 scale=1 border=1");				//
				saveAs("Tiff", Clean_singlets_directory+list[i]+"-montage.tif");			//
			
				// get Kinetoplast nuclei distance
				Kinetoplast_nuclei_distance = Get_pythagorean_distance(Kinetoplast_centroids_X[0], Nuclei_centroids_X[0], Kinetoplast_centroids_Y[0], Nuclei_centroids_Y[0]);
				Long_string = list[i]+","+Circularity+","+Solidity+","+Skeleton_area+","+Skeleton_length+","+Convert_to_microns(Skeleton_length)+","+Convert_to_microns(Cumulative_ridge_length);
				Long_string = Long_string+","+Number_of_nuclei+","+Number_of_kinetoplasts+","+Nuclei_centroids_X[0]+","+Nuclei_centroids_Y[0]+","+Convert_to_microns(Nuclei_minimum_distance)+","+Convert_to_microns(Nuc_min_distance_to_skeleton_end); 
				Long_string = Long_string+","+Kinetoplast_centroids_X[0]+","+Kinetoplast_centroids_Y[0]+","+Convert_to_microns(Kinetoplast_minimum_distance)+","+Convert_to_microns(Kin_min_distance_to_skeleton_end)+","+Convert_to_microns(KN_along_skeleton)+","+Convert_to_microns(Kinetoplast_nuclei_distance)+","+Skeleton_quality;
				Long_string = Long_string+",\n";
				File.append(Long_string, Clean_singlets_directory + "population data.txt");
				}
			
			// sort dividers
			if ( (2==Number_of_nuclei && 2==Number_of_kinetoplasts && niceness==1) || (1==Number_of_nuclei && 2==Number_of_kinetoplasts && niceness==1) )
				{
				print("Dividers found. Making montage...");
				run("Images to Stack", "name=Stack use");									//
				saveAs("Tiff", Clean_dividers_directory+list[i]);							//
				run("Make Montage...", "columns=10 rows=1 scale=1 border=1");				//
				saveAs("Tiff", Clean_dividers_directory+list[i]+"-montage.tif");			//
				}
				
			Long_string = list[i]+","+Circularity+","+Solidity+","+Skeleton_area+","+Skeleton_length+","+Convert_to_microns(Skeleton_length)+","+Convert_to_microns(Cumulative_ridge_length);
			Long_string = Long_string+","+Number_of_nuclei+","+Number_of_kinetoplasts+","+Nuclei_centroids_X[0]+","+Nuclei_centroids_Y[0]+","+Convert_to_microns(Nuclei_minimum_distance)+","+Convert_to_microns(Nuc_min_distance_to_skeleton_end); 
			Long_string = Long_string+","+Kinetoplast_centroids_X[0]+","+Kinetoplast_centroids_Y[0]+","+Convert_to_microns(Kinetoplast_minimum_distance)+","+Convert_to_microns(Kin_min_distance_to_skeleton_end)+","+Convert_to_microns(KN_along_skeleton)+","+Convert_to_microns(Kinetoplast_nuclei_distance)+","+Skeleton_quality;
			Long_string = Long_string+",\n";
			File.append(Long_string, Analysed_cells_directory + "population data.txt");

//############################ CONLUDES SORTING ANALYSED CELLS ########################################################################			
			Clear_non_image_windows();
			Close_open_images();
			Save_log();
			}
		else {End_credits();}
		}
	else {End_credits();}
	}
